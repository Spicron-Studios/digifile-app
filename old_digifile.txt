This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
app/
  actions/
    appointments.ts
    auth-actions.ts
    auth.ts
  api/
    appointments/
      route.ts
    auth/
      [...nextauth]/
        route.ts
    calendar/
      route.ts
    files/
      [uid]/
        db_read.ts
        db_write.ts
        other_fn.ts
        route.ts
      notes/
        route.ts
      route.ts
    practice-types/
      route.ts
    register/
      route.ts
    settings/
      organization/
        [uid]/
          consent/
            [number]/
              route.ts
          logo/
            route.ts
          upload/
            route.ts
          route.ts
        route.ts
      users/
        [uid]/
          roles/
            route.ts
          route.ts
        roles/
          route.ts
        route.ts
    route.ts
  components/
    providers/
      AuthProvider.tsx
    ui/
      account-selector/
        account-chip.tsx
        account-list.tsx
        account-selector.tsx
        index.tsx
      appointment/
        appointment-modal.tsx
      button.tsx
      calendar.tsx
      card.tsx
      checkbox.tsx
      client-header.tsx
      collapsible-sidebar.tsx
      consent-modal.tsx
      date-time-picker.tsx
      dialog.tsx
      editor.tsx
      header.tsx
      input.tsx
      label.tsx
      popover.tsx
      radio-group.tsx
      scroll-area.tsx
      select.tsx
      sidebar.tsx
      tabs.tsx
      textarea.tsx
      tooltip.tsx
  hooks/
    use-session.ts
  lib/
    logger/
      index.ts
      logger.service.ts
      types.ts
    auth.ts
    config.ts
    prisma.ts
    supabase.ts
    utils.ts
  login/
    registration/
      components/
        consent-row.tsx
        verification-modal.tsx
      contact-details-form.tsx
      extra-info-form.tsx
      page.tsx
      practice-info-form.tsx
      user-creation-form.tsx
    signin/
      page.tsx
  sites/
    calendar/
      page.tsx
    file-data/
      [uid]/
        layout.tsx
        page.tsx
      page.tsx
    settings/
      DebitOrderSettings.tsx
      GeneralSettings.tsx
      loading.tsx
      page.tsx
      UserSettings.tsx
    layout.tsx
    page.tsx
  types/
    calendar.ts
    next-auth.d.ts
  utils/
    calendar.ts
  global-error.tsx
  globals.css
  layout.tsx
  page.tsx
Helperfiles/
  .cursorrules
  .database_rules
  infopacket.txt
  ItemsToNote.md
prisma/
  migrations/
    migration_lock.toml
  schema.prisma
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
.eslintrc.json
.gitignore
components.json
instrumentation.ts
middleware.ts
next.config.js
package.json
postcss.config.mjs
README.md
tailwind.config.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="app/actions/auth-actions.ts">
'use server'

import { signOut } from '@/app/lib/auth'
import { cookies } from 'next/headers'

export async function handleSignOut() {
  // Await the cookies() call
  const cookieStore = await cookies()
  
  // Clear auth cookies
  cookieStore.delete('next-auth.session-token')
  cookieStore.delete('__Secure-next-auth.session-token')
  
  // Call the auth signOut function
  await signOut()
  
  return { success: true }
}
</file>

<file path="app/api/files/notes/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';
import prisma from '@/app/lib/prisma';
import chalk from 'chalk';

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

export async function POST(request: NextRequest) {
  try {
    const data = await request.json();
    
    // Validate the required fields
    if (!data.notes || !data.tabType || !data.timeStamp) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }
    
    // Create a new note in the database
    const noteUid = uuidv4();
    //log data with chalk stringyfy 
    //console.log(chalk.blue(data.orgId));
    console.log(chalk.green(data.fileInfoPatientId));
    //console.log(chalk.green(data.patientId));
    //console.log(chalk.green(data.timeStamp));
    //console.log(chalk.green(data.notes));
    //console.log(chalk.green(data.tabType));
    
    const newNote = await prisma.tab_notes.create({
      data: {
        uid: noteUid,
        orgid: data.orgId,
        fileinfo_patient_id: data.fileInfoPatientId,
        personid: data.patientId,
        time_stamp: new Date(data.timeStamp),
        notes: data.notes,
        tab_type: data.tabType, // 'file' or 'clinical'
        active: true,
        date_created: new Date(),
        last_edit: new Date()
      }
    });
    
    // Handle file uploads
    const fileRecords = [];
    
    if (data.files && data.files.length > 0) {
      for (const fileData of data.files) {
        try {
          // Generate a unique filename while preserving the extension
          const fileExtension = fileData.name.split('.').pop();
          const uniqueFileName = `${uuidv4()}.${fileExtension}`;
          const storageLocation = `${data.orgId}/note-docs/${uniqueFileName}`;
          
          // Convert base64 to file
          const base64Data = fileData.content.split(';base64,').pop();
          const fileBuffer = Buffer.from(base64Data, 'base64');
          
          // Upload to Supabase
          const { data: uploadData, error } = await supabase.storage
            .from('note-docs')
            .upload(storageLocation, fileBuffer, {
              contentType: fileData.type
            });
            
          if (error) {
            console.error('Supabase storage upload error:', error);
            continue;
          }
          
          // Create record in tab_files
          const fileUid = uuidv4();
          const fileRecord = await prisma.tab_files.create({
            data: {
              uid: fileUid,
              orgid: data.orgId,
              tab_notes_id: noteUid,
              file_name: fileData.name,
              file_type: fileData.type,
              file_location: storageLocation,
              active: true,
              date_created: new Date(),
              last_edit: new Date()
            }
          });
          
          fileRecords.push({
            uid: fileRecord.uid,
            file_name: fileRecord.file_name,
            file_type: fileRecord.file_type,
            file_location: fileRecord.file_location
          });
        } catch (fileError) {
          console.error('Error processing file:', fileError);
        }
      }
    }
    
    // Return the complete note data with file records
    const completeNote = {
      uid: newNote.uid,
      time_stamp: newNote.time_stamp,
      notes: newNote.notes,
      tab_type: newNote.tab_type,
      files: fileRecords
    };
    
    return NextResponse.json(completeNote, { status: 201 });
    
  } catch (error) {
    console.error('Error creating note:', error);
    return NextResponse.json({ error: 'Failed to create note' }, { status: 500 });
  }
}
</file>

<file path="app/api/practice-types/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'

export async function GET() {
  try {
    const practiceTypes = await prisma.practice_Types.findMany({
      select: {
        uuid: true,
        codes: true,
        name: true
      },
      where: {
        codes: { not: null },
        name: { not: null }
      }
    })

    return NextResponse.json(practiceTypes)
  } catch (error) {
    console.error('Error fetching practice types:', error)
    return NextResponse.json(
      { error: 'Failed to fetch practice types' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/register/route.ts">
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { v4 as uuidv4 } from 'uuid';

const prisma = new PrismaClient();

export async function POST(request: Request) {
  try {
    const data = await request.json();
    
    // Create organization
    const organization = await prisma.organization_info.create({
      data: {
        uid: uuidv4(),
        practice_name: data.practiceInfo.practiceName,
        bhf_number: data.practiceInfo.bhfNumber,
        hpcsa: data.practiceInfo.hpcsaNumber,
        practice_type: data.practiceInfo.practiceType,
        vat_no: data.practiceInfo.vatNumber,
        practice_telephone: data.contactDetails.practiceTelephone,
        accounts_telephone: data.contactDetails.accountsTelephone,
        postal: data.contactDetails.postalCode,
        address: data.contactDetails.fullAddress,
        email: data.contactDetails.practiceEmail,
        cell: data.contactDetails.cellNumber,
        fax: data.contactDetails.fax,
        active: true,
        date_created: new Date(),
      },
    });

    // Create user
    const user = await prisma.users.create({
      data: {
        uid: uuidv4(),
        first_name: data.userCreation.firstName,
        surname: data.userCreation.lastName,
        username: data.userCreation.username,
        secret_key: data.userCreation.password, // Note: Should be hashed in production
        orgid: organization.uid,
        active: true,
        date_created: new Date(),
      },
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'Registration failed' },
      { status: 500 }
    );
  }
}
</file>

<file path="app/api/settings/organization/[uid]/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

export async function PUT(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized - No organization ID found' },
        { status: 401 }
      )
    }

    const data = await request.json()
    if (!data) {
      return NextResponse.json(
        { error: 'Invalid request body' },
        { status: 400 }
      )
    }

    if (params.uid !== session.user.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized - Organization ID mismatch' },
        { status: 403 }
      )
    }

    const updatedOrg = await prisma.organization_info.update({
      where: {
        uid: session.user.orgId
      },
      data: {
        practice_name: data.practice_name ?? undefined,
        practice_type: data.practice_type ?? undefined,
        bhf_number: data.bhf_number ?? undefined,
        hpcsa: data.hpcsa ?? undefined,
        vat_no: data.vat_no ?? undefined,
        address: data.address ?? undefined,
        postal: data.postal ?? undefined,
        practice_telephone: data.practice_telephone ?? undefined,
        accounts_telephone: data.accounts_telephone ?? undefined,
        cell: data.cell ?? undefined,
        fax: data.fax ?? undefined,
        email: data.email ?? undefined,
        last_edit: new Date()
      }
    })

    return NextResponse.json(updatedOrg)
  } catch (error) {
    console.error('Failed to update organization:', error)
    return NextResponse.json(
      { error: 'Failed to update organization' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/settings/organization/route.ts">
import { NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

export async function GET() {
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized - No organization ID found' }, 
        { status: 401 }
      )
    }

    const orgInfo = await prisma.organization_info.findFirst({
      where: {
        uid: session.user.orgId
      }
    })

    if (!orgInfo) {
      return NextResponse.json(
        { error: 'Organization not found' },
        { status: 404 }
      )
    }

    return NextResponse.json(orgInfo)
  } catch (error) {
    console.error('Failed to fetch organization info:', error)
    return NextResponse.json(
      { error: 'Failed to fetch organization info' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/components/providers/AuthProvider.tsx">
'use client'

import { SessionProvider } from "next-auth/react"

export const AuthProvider = ({ children }: { children: React.ReactNode }) => {
  return <SessionProvider>{children}</SessionProvider>
}
</file>

<file path="app/components/ui/account-selector/account-chip.tsx">
import { X } from 'lucide-react'
import { Account } from "@/app/types/calendar"

interface AccountChipProps {
  account: Account
  color: string
  onRemove: () => void
}

export function AccountChip({ account, color, onRemove }: AccountChipProps) {
  return (
    <div 
      className="flex items-center gap-2 px-2 py-1 rounded-full bg-white border 
                 border-gray-200 shadow-sm hover:bg-gray-50 transition-colors"
    >
      <div 
        className={`w-2 h-2 rounded-full ${color}`} 
        aria-hidden="true"
      />
      <span className="text-sm font-medium truncate max-w-[120px]">
        {account.Name}
      </span>
      <button
        onClick={onRemove}
        className="p-0.5 hover:bg-gray-200 rounded-full transition-colors"
        aria-label={`Remove ${account.Name}`}
      >
        <X className="h-3 w-3 text-gray-500" />
      </button>
    </div>
  )
}
</file>

<file path="app/components/ui/account-selector/account-list.tsx">
import { Account } from "@/app/types/calendar"
import { AccountChip } from "./account-chip"

interface AccountListProps {
  accounts: Account[]
  selectedAccounts: string[]
  onRemoveAccount: (accountId: string) => void
}

export function AccountList({ accounts, selectedAccounts, onRemoveAccount }: AccountListProps) {
  const selectedAccountObjects = accounts.filter(account => 
    selectedAccounts.includes(account.AccountID)
  )

  return (
    <div className="flex gap-2 items-center overflow-x-auto py-1 px-2 min-h-[40px]">
      {selectedAccountObjects.map(account => (
        <AccountChip
          key={account.AccountID}
          account={account}
          color={account.color}
          onRemove={() => onRemoveAccount(account.AccountID)}
        />
      ))}
    </div>
  )
}
</file>

<file path="app/components/ui/account-selector/index.tsx">
export { AccountSelector } from './account-selector'
</file>

<file path="app/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/app/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }
</file>

<file path="app/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/app/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="app/components/ui/checkbox.tsx">
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/app/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }
</file>

<file path="app/components/ui/client-header.tsx">
'use client'

import { Button } from "@/app/components/ui/button"
import { LogOut, User } from 'lucide-react'
import { signOut } from 'next-auth/react'
import { useRouter } from 'next/navigation'
import type { Session } from 'next-auth'

interface ClientHeaderProps {
  session: Session | null
}

export function ClientHeader({ session }: ClientHeaderProps) {
  const router = useRouter()

  const handleSignOutClick = async () => {
    try {
      // Call signOut with redirect false to handle navigation manually
      await signOut({ 
        redirect: false,
        callbackUrl: '/login/signin'
      })
      
      // Force a hard navigation to signin page
      window.location.href = '/login/signin'
    } catch (error) {
      console.error('Error signing out:', error)
      // Fallback navigation if the signOut fails
      router.push('/login/signin')
    }
  }

  return (
    <header className="h-16 border-b bg-white/75 backdrop-blur-sm">
      <div className="flex h-full items-center justify-end px-6 gap-4">
        <div className="flex items-center gap-2">
          <User className="h-4 w-4 text-muted-foreground" />
          <span className="text-sm text-muted-foreground">
            {session?.user?.name || 'Guest'}
          </span>
        </div>
        <Button 
          variant="ghost" 
          size="sm"
          onClick={handleSignOutClick}
          className="gap-2"
        >
          <LogOut className="h-4 w-4" />
          Sign Out
        </Button>
      </div>
    </header>
  )
}
</file>

<file path="app/components/ui/date-time-picker.tsx">
"use client"

import React from "react"
import ReactDatePicker from "react-datepicker"
import "react-datepicker/dist/react-datepicker.css"

interface DateTimePickerProps {
  id: string
  value?: Date
  onChange?: (date: Date | null) => void
}

export function DateTimePicker({ id, value, onChange }: DateTimePickerProps) {
  return (
    <ReactDatePicker
      id={id}
      selected={value}
      onChange={onChange}
      showTimeSelect
      dateFormat="Pp"
      className="w-full p-2 border rounded"
    />
  )
}
</file>

<file path="app/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/app/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}
</file>

<file path="app/components/ui/editor.tsx">
'use client';

import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';

interface EditorProps {
  content: string;
  onChange?: (content: string) => void;
}

export function Editor({ content, onChange }: EditorProps) {
  const editor = useEditor({
    extensions: [StarterKit],
    content: content,
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl mx-auto focus:outline-none',
      },
    },
    onUpdate: ({ editor }) => {
      onChange?.(editor.getHTML());
    },
  });

  return (
    <div className="min-h-[200px] w-full rounded-md border border-input bg-background px-3 py-2">
      <EditorContent editor={editor} />
    </div>
  );
}
</file>

<file path="app/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/app/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 origin-[--radix-popover-content-transform-origin]",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }
</file>

<file path="app/components/ui/radio-group.tsx">
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/app/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }
</file>

<file path="app/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/app/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }
</file>

<file path="app/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/app/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}
</file>

<file path="app/components/ui/sidebar.tsx">
'use client'

import * as React from 'react'
import { createContext, useContext, useState } from 'react'
import { cn } from '../../lib/utils'

type SidebarState = 'expanded' | 'collapsed'
type SidebarContextType = {
  state: SidebarState
  toggle: () => void
}

const SidebarContext = createContext<SidebarContextType | undefined>(undefined)

export function SidebarProvider({ children }: { children: React.ReactNode }) {
  const [state, setState] = useState<SidebarState>('expanded')
  
  const toggle = () => {
    console.log('Toggle called, current state:', state)
    setState(s => {
      const newState = s === 'expanded' ? 'collapsed' : 'expanded'
      console.log('Setting new state to:', newState)
      return newState
    })
  }

  return (
    <SidebarContext.Provider value={{ state, toggle }}>
      {children}
    </SidebarContext.Provider>
  )
}

export const useSidebar = () => {
  const context = useContext(SidebarContext)
  if (!context) throw new Error('useSidebar must be used within SidebarProvider')
  return context
}

export const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & { collapsible?: 'icon' }
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex flex-col h-full", className)} {...props} />
))
Sidebar.displayName = 'Sidebar'

export const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={className} {...props} />
))
SidebarHeader.displayName = 'SidebarHeader'

export const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex-1", className)} {...props} />
))
SidebarContent.displayName = 'SidebarContent'

export const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("mt-auto", className)} {...props} />
))
SidebarFooter.displayName = 'SidebarFooter'

export const SidebarTrigger = React.forwardRef<
  HTMLButtonElement,
  React.ButtonHTMLAttributes<HTMLButtonElement>
>(({ className, ...props }, ref) => (
  <button ref={ref} className={className} {...props} />
))
SidebarTrigger.displayName = 'SidebarTrigger'
</file>

<file path="app/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/app/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="app/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/app/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }
</file>

<file path="app/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/app/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="app/lib/logger/index.ts">
export { Logger } from './logger.service';
export * from './types';
</file>

<file path="app/lib/logger/types.ts">
export type LogLevel = 'ERROR' | 'WARNING' | 'INFO' | 'DEBUG';

export interface LoggerConfig {
  logLevels: {
    [key in LogLevel]: boolean;
  };
  maxFileSize: number; // in bytes
  maxLogFiles: number;
  logDirectory: string;
}

export interface LogEntry {
  timestamp: string;
  level: LogLevel;
  fileName: string;
  message: string;
}
</file>

<file path="app/lib/prisma.ts">
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare global {
  // Allow global `var` declaration
  // eslint-disable-next-line no-var
  var prisma: PrismaClient | undefined
}

const prisma = global.prisma || prismaClientSingleton()

if (process.env.NODE_ENV !== 'production') global.prisma = prisma

export default prisma
</file>

<file path="app/lib/supabase.ts">
import { createClient } from '@supabase/supabase-js'

let supabase: ReturnType<typeof createClient> | null = null

export function getSupabaseClient() {
  if (supabase) return supabase

  // Only create client if URL and key are available
  if (process.env.NEXT_PUBLIC_SUPABASE_URL && process.env.SUPABASE_SERVICE_ROLE_KEY) {
    supabase = createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )
  }

  return supabase
}
</file>

<file path="app/login/registration/components/consent-row.tsx">
'use client'

import { useState, useRef } from 'react'
import { Button } from "@/app/components/ui/button"
import { Label } from "@/app/components/ui/label"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/app/components/ui/dialog"

interface ConsentRowProps {
  number: number
  content: string | null
  onUpload: (file: File) => void
}

export function ConsentRow({ number, content, onUpload }: ConsentRowProps) {
  const [isOpen, setIsOpen] = useState(false)
  const fileInputRef = useRef<HTMLInputElement | null>(null)

  const handleFileUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      onUpload(file)
    }
  }

  return (
    <div className="flex items-center gap-4">
      <Label className="w-24">Consent {number}</Label>
      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogTrigger asChild>
          <Button variant="outline" disabled={!content}>View</Button>
        </DialogTrigger>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Consent {number}</DialogTitle>
          </DialogHeader>
          <div className="max-h-[60vh] overflow-y-auto whitespace-pre-wrap">
            {content || 'No content uploaded'}
          </div>
        </DialogContent>
      </Dialog>
      <input
        type="file"
        ref={fileInputRef}
        onChange={handleFileUpload}
        accept=".txt,.doc,.docx,.pdf"
        className="hidden"
      />
      <Button 
        variant="secondary"
        onClick={() => fileInputRef.current?.click()}
      >
        Upload
      </Button>
    </div>
  )
}
</file>

<file path="app/login/registration/components/verification-modal.tsx">
'use client'

import { useState } from 'react'
import { X } from 'lucide-react'
import { Button } from "@/app/components/ui/button"
import { Input } from "@/app/components/ui/input"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/app/components/ui/dialog"

interface VerificationModalProps {
  isOpen: boolean
  onClose: () => void
  onSubmit: () => void
}

export function VerificationModal({ isOpen, onClose, onSubmit }: VerificationModalProps) {
  const [emailCode, setEmailCode] = useState('')
  const [smsCode, setSmsCode] = useState('')
  const [emailSent, setEmailSent] = useState(false)
  const [smsSent, setSmsSent] = useState(false)
  const [emailVerified, setEmailVerified] = useState(false)
  const [smsVerified, setSmsVerified] = useState(false)

  const handleSendEmail = () => {
    // TODO: Implement email sending logic
    setEmailSent(true)
  }

  const handleSendSMS = () => {
    // TODO: Implement SMS sending logic
    setSmsSent(true)
  }

  const handleVerifyEmail = () => {
    // TODO: Implement email verification logic
    setEmailVerified(true)
  }

  const handleVerifySMS = () => {
    // TODO: Implement SMS verification logic
    setSmsVerified(true)
  }

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="sm:max-w-md">
        <DialogHeader>
          <DialogTitle>Verify Your Identity</DialogTitle>
          <Button
            variant="ghost"
            className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100"
            onClick={onClose}
          >
            <X className="h-4 w-4" />
          </Button>
        </DialogHeader>
        <div className="space-y-6">
          {/* Email Verification */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <span>Use Email</span>
              <Button 
                onClick={handleSendEmail}
                disabled={emailSent}
              >
                Send
              </Button>
            </div>
            <div className="flex gap-4">
              <Input
                placeholder="Enter verification code"
                value={emailCode}
                onChange={(e) => setEmailCode(e.target.value)}
                disabled={!emailSent || emailVerified}
              />
              <Button
                onClick={handleVerifyEmail}
                disabled={!emailSent || emailVerified || !emailCode}
              >
                Verify
              </Button>
            </div>
          </div>

          {/* SMS Verification */}
          <div className="space-y-4">
            <div className="flex items-center justify-between">
              <span>Use SMS</span>
              <Button 
                onClick={handleSendSMS}
                disabled={smsSent}
              >
                Send
              </Button>
            </div>
            <div className="flex gap-4">
              <Input
                placeholder="Enter verification code"
                value={smsCode}
                onChange={(e) => setSmsCode(e.target.value)}
                disabled={!smsSent || smsVerified}
              />
              <Button
                onClick={handleVerifySMS}
                disabled={!smsSent || smsVerified || !smsCode}
              >
                Verify
              </Button>
            </div>
          </div>

          {/* Submit Button */}
          <div className="flex justify-end">
            <Button
              onClick={onSubmit}
              disabled={!emailVerified || !smsVerified}
            >
              Submit
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="app/sites/settings/DebitOrderSettings.tsx">
'use client'

import { ScrollArea } from "@/app/components/ui/scroll-area"

export function DebitOrderSettings() {
  return (
    <ScrollArea className="h-full">
      <div className="p-4">
        <h2 className="text-2xl font-bold mb-4">Debit Order</h2>
        <p className="text-gray-600">Debit order content goes here.</p>
      </div>
    </ScrollArea>
  )
}
</file>

<file path="app/sites/settings/loading.tsx">
import React from 'react'

const loading = () => {
  return (
    <div>loading...</div>
  )
}

export default loading
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path=".eslintrc.json">
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="postcss.config.mjs">
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;
</file>

<file path="README.md">
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.
</file>

<file path="app/api/auth/[...nextauth]/route.ts">
import { GET, POST } from "@/app/lib/auth"

export { GET, POST }
</file>

<file path="app/api/files/[uid]/db_write.ts">
import prisma from '@/app/lib/prisma';
import chalk from 'chalk';
import { v4 as uuidv4 } from 'uuid';

// Handle PUT requests to update an existing file
export async function handleUpdateFile(uid: string, data: any, orgId: string) {
  try {
    console.log(chalk.blue.bold(`🔍 API: Updating file with UID: ${uid}`));
    
    // Log the full received data object for debugging
    console.log(chalk.yellow('📦 API: RECEIVED DATA OBJECT:'));
    console.log(JSON.stringify(data, null, 2));

    // The uid from params is our identifier for file_info
    const fileUid = uid;
    
    // First, check if the file_info record exists
    const existingFileInfo = await prisma.file_info.findUnique({
      where: { uid: fileUid },
      include: {
        fileinfo_patient: {
          where: { active: true },
          include: {
            patient: true
          }
        }
      }
    });
    
    console.log(chalk.cyan(`🔍 API: Existing file_info found: ${!!existingFileInfo}`));
    if (existingFileInfo) {
      console.log(chalk.cyan(`🔍 API: Has fileinfo_patient relationships: ${existingFileInfo.fileinfo_patient.length > 0}`));
    }

    // Upsert the file_info record
    const upsertedFileInfo = await prisma.file_info.upsert({
      where: { uid: fileUid },
      update: {
        file_number: data.file_number,
        account_number: data.account_number,
        referral_doc_name: data.referral_doc_name,
        referral_doc_number: data.referral_doc_number,
        last_edit: new Date(),
      },
      create: {
        uid: fileUid,
        file_number: data.file_number || '',
        account_number: data.account_number || '',
        referral_doc_name: data.referral_doc_name || '',
        referral_doc_number: data.referral_doc_number || '',
        orgid: orgId,
        active: true,
        date_created: new Date(),
        last_edit: new Date()
      }
    });
    
    console.log(chalk.green(`✅ API: File_info upserted with UID: ${upsertedFileInfo.uid}`));
    
    // Process patient information if provided
    if (data.patient) {
      console.log(chalk.cyan('🧑 API: Processing patient data'));
      
      // Parse date of birth if provided
      let dobDate = null;
      if (data.patient.dob) {
        const dobParts = data.patient.dob.split('/');
        if (dobParts.length === 3) {
          dobDate = new Date(
            parseInt(dobParts[0]), // Year
            parseInt(dobParts[1]) - 1, // Month (0-indexed)
            parseInt(dobParts[2]) // Day
          );
        }
      }
      
      // Find existing fileinfo_patient relationship if any
      let existingRelation = null;
      let existingPatient = null;
      
      if (existingFileInfo && existingFileInfo.fileinfo_patient.length > 0) {
        existingRelation = existingFileInfo.fileinfo_patient[0];
        existingPatient = existingRelation.patient;
        console.log(chalk.yellow(`🔄 API: Found existing patient relationship with UID: ${existingPatient.uid}`));
      }
      
      // Decide whether to update existing patient or create new one
      if (existingPatient) {
        // Update existing patient
        console.log(chalk.yellow(`🔄 API: Updating existing patient with UID: ${existingPatient.uid}`));
        
        await prisma.patient.update({
          where: { uid: existingPatient.uid },
          data: {
            title: data.patient.title,
            name: data.patient.name,
            initials: data.patient.initials,
            surname: data.patient.surname,
            date_of_birth: dobDate,
            gender: data.patient.gender,
            cell_phone: data.patient.cell_phone,
            additional_name: data.patient.additional_name,
            additional_cell: data.patient.additional_cell,
            email: data.patient.email,
            address: data.patient.address,
            last_edit: new Date()
          }
        });
        
        console.log(chalk.green('✅ API: Existing patient updated'));
      } else if (data.patient.name || data.patient.surname) {
        // Create new patient and relationship
        const newPatientUid = uuidv4();
        console.log(chalk.green(`➕ API: Creating new patient with UID: ${newPatientUid}`));
        
        // Create the patient record
        const newPatient = await prisma.patient.create({
          data: {
            uid: newPatientUid,
            id: data.patient.id || '',
            title: data.patient.title || '',
            name: data.patient.name || '',
            initials: data.patient.initials || '',
            surname: data.patient.surname || '',
            date_of_birth: dobDate,
            gender: data.patient.gender || '',
            cell_phone: data.patient.cell_phone || '',
            additional_name: data.patient.additional_name || '',
            additional_cell: data.patient.additional_cell || '',
            email: data.patient.email || '',
            address: data.patient.address || '',
            orgid: orgId,
            active: true,
            date_created: new Date(),
            last_edit: new Date()
          }
        });
        
        // Create the fileinfo_patient relationship
        const newRelationUid = uuidv4();
        console.log(chalk.green(`➕ API: Creating fileinfo_patient relationship with UID: ${newRelationUid}`));
        
        await prisma.fileinfo_patient.create({
          data: {
            uid: newRelationUid,
            fileid: fileUid,
            patientid: newPatientUid,
            orgid: orgId,
            active: true,
            date_created: new Date(),
            last_edit: new Date()
          }
        });
        
        console.log(chalk.green('✅ API: New patient and relationship created successfully'));
      }
    }
    
    // Process medical cover information
    if (data.medical_cover) {
      console.log(chalk.cyan('💊 API: Processing medical cover data'));
      
      // Handle based on medical cover type
      if (data.medical_cover.type === 'medical-aid') {
        // Handle medical aid type
        await processMedicalAid(fileUid, data.medical_cover, orgId);
      } else if (data.medical_cover.type === 'injury-on-duty') {
        // Handle injury on duty type
        await processInjuryOnDuty(fileUid, data.medical_cover, orgId);
      }
      // For 'private' type, no additional records needed
    }
    
    // Fetch the updated file data to return
    const updatedFileData = await prisma.file_info.findUnique({
      where: { uid: fileUid },
      include: {
        fileinfo_patient: {
          where: { active: true },
          include: {
            patient: true
          }
        }
      }
    });
    
    if (!updatedFileData) {
      console.log(chalk.red('❌ API: Failed to fetch updated file data'));
      return { error: 'File not found after update', status: 404 };
    }
    
    // Get the associated patient data if available
    const filePatient = updatedFileData.fileinfo_patient[0]?.patient || null;
    
    // Format date of birth if it exists
    let formattedDob = '';
    if (filePatient?.date_of_birth) {
      const dob = new Date(filePatient.date_of_birth);
      formattedDob = `${dob.getFullYear()}/${String(dob.getMonth() + 1).padStart(2, '0')}/${String(dob.getDate()).padStart(2, '0')}`;
    }
    
    // Prepare the response data
    const responseData = {
      uid: updatedFileData.uid,
      file_number: updatedFileData.file_number || '',
      account_number: updatedFileData.account_number || '',
      referral_doc_name: updatedFileData.referral_doc_name || '',
      referral_doc_number: updatedFileData.referral_doc_number || '',
      patient: filePatient ? {
        id: filePatient.id || '',
        title: filePatient.title || '',
        name: filePatient.name || '',
        initials: filePatient.initials || '',
        surname: filePatient.surname || '',
        dob: formattedDob,
        gender: filePatient.gender || '',
        cell_phone: filePatient.cell_phone || '',
        additional_name: filePatient.additional_name || '',
        additional_cell: filePatient.additional_cell || '',
        email: filePatient.email || '',
        address: filePatient.address || ''
      } : {
        id: '',
        title: '',
        name: '',
        initials: '',
        surname: '',
        dob: '',
        gender: '',
        cell_phone: '',
        additional_name: '',
        additional_cell: '',
        email: '',
        address: ''
      },
      medical_cover: data.medical_cover || {
        type: 'medical-aid',
        same_as_patient: false,
        member: {
          id: '',
          name: '',
          initials: '',
          surname: '',
          dob: '',
          cell: '',
          email: '',
          address: ''
        },
        medical_aid: {
          name: '',
          membership_number: '',
          dependent_code: ''
        }
      }
    };
    
    console.log(chalk.green('✅ API: File update completed successfully'));
    return { data: responseData, status: 200 };
  } catch (error) {
    console.error(chalk.red('💥 API: Error updating file:'), error);
    return { error: 'Failed to update file', status: 500 };
  }
}

// Handle POST requests to create a new file
export async function handleCreateFile(data: any, orgId: string) {
  try {
    console.log(chalk.blue.bold(`🔍 API: Creating new file`));
    
    // Log the full received data object for debugging
    console.log(chalk.yellow('📦 API: RECEIVED DATA OBJECT FOR NEW FILE:'));
    console.log(JSON.stringify(data, null, 2));
    
    // Generate a new UUID for this file
    const newFileUid = uuidv4();
    console.log(chalk.green(`🆕 API: Generated new file UID: ${newFileUid}`));
    
    // Create the file_info record first
    const newFileInfo = await prisma.file_info.create({
      data: {
        uid: newFileUid,
        file_number: data.file_number || '',
        account_number: data.account_number || '',
        referral_doc_name: data.referral_doc_name || '',
        referral_doc_number: data.referral_doc_number || '',
        orgid: orgId,
        active: true,
        date_created: new Date(),
        last_edit: new Date()
      }
    });
    
    console.log(chalk.green(`✅ API: New file_info created with UID: ${newFileInfo.uid}`));
    
    // Create patient record if patient data is provided
    let patientData = null;
    
    if (data.patient && (data.patient.name || data.patient.surname)) {
      console.log(chalk.cyan('🧑 API: Processing patient data for new file'));
      
      // Parse date of birth if provided
      let dobDate = null;
      if (data.patient.dob) {
        const dobParts = data.patient.dob.split('/');
        if (dobParts.length === 3) {
          dobDate = new Date(
            parseInt(dobParts[0]), // Year
            parseInt(dobParts[1]) - 1, // Month (0-indexed)
            parseInt(dobParts[2]) // Day
          );
        }
      }
      
      // Generate a new UUID for the patient
      const newPatientUid = uuidv4();
      console.log(chalk.green(`➕ API: Creating new patient with UID: ${newPatientUid}`));
      
      // Create the patient record
      const newPatient = await prisma.patient.create({
        data: {
          uid: newPatientUid,
          id: data.patient.id || '',
          title: data.patient.title || '',
          name: data.patient.name || '',
          initials: data.patient.initials || '',
          surname: data.patient.surname || '',
          date_of_birth: dobDate,
          gender: data.patient.gender || '',
          cell_phone: data.patient.cell_phone || '',
          additional_name: data.patient.additional_name || '',
          additional_cell: data.patient.additional_cell || '',
          email: data.patient.email || '',
          address: data.patient.address || '',
          orgid: orgId,
          active: true,
          date_created: new Date(),
          last_edit: new Date()
        }
      });
      
      console.log(chalk.green(`✅ API: Patient created with UID: ${newPatient.uid}`));
      
      // Generate a new UUID for the relationship
      const relationshipUid = uuidv4();
      
      // Create the fileinfo_patient relationship
      await prisma.fileinfo_patient.create({
        data: {
          uid: relationshipUid,
          fileid: newFileUid,
          patientid: newPatientUid,
          orgid: orgId,
          active: true,
          date_created: new Date(),
          last_edit: new Date()
        }
      });
      
      console.log(chalk.green(`✅ API: fileinfo_patient relationship created with UID: ${relationshipUid}`));
      
      // Store the patient data for the response
      patientData = {
        id: data.patient.id || '',
        title: data.patient.title || '',
        name: data.patient.name || '',
        initials: data.patient.initials || '',
        surname: data.patient.surname || '',
        dob: data.patient.dob || '',
        gender: data.patient.gender || '',
        cell_phone: data.patient.cell_phone || '',
        additional_name: data.patient.additional_name || '',
        additional_cell: data.patient.additional_cell || '',
        email: data.patient.email || '',
        address: data.patient.address || ''
      };
    }
    
    // Process medical cover information
    if (data.medical_cover) {
      console.log(chalk.cyan('💊 API: Processing medical cover data for new file'));
      
      // Handle based on medical cover type
      if (data.medical_cover.type === 'medical-aid') {
        // Handle medical aid type
        await processMedicalAid(newFileUid, data.medical_cover, orgId);
      } else if (data.medical_cover.type === 'injury-on-duty') {
        // Handle injury on duty type
        await processInjuryOnDuty(newFileUid, data.medical_cover, orgId);
      }
      // For 'private' type, no additional records needed
    }
    
    // Prepare the response data
    const responseData = {
      uid: newFileUid,
      file_number: data.file_number || '',
      account_number: data.account_number || '',
      referral_doc_name: data.referral_doc_name || '',
      referral_doc_number: data.referral_doc_number || '',
      patient: patientData || {
        id: '',
        title: '',
        name: '',
        initials: '',
        surname: '',
        dob: '',
        gender: '',
        cell_phone: '',
        additional_name: '',
        additional_cell: '',
        email: '',
        address: ''
      },
      medical_cover: data.medical_cover || {
        type: 'medical-aid',
        same_as_patient: false,
        member: {
          id: '',
          name: '',
          initials: '',
          surname: '',
          dob: '',
          cell: '',
          email: '',
          address: ''
        },
        medical_aid: {
          name: '',
          membership_number: '',
          dependent_code: ''
        }
      }
    };
    
    console.log(chalk.green('✅ API: New file created successfully'));
    return { data: responseData, status: 200 };
  } catch (error) {
    console.error(chalk.red('💥 API: Error creating new file:'), error);
    return { error: 'Failed to create new file', status: 500 };
  }
}

// Helper function to process medical aid data
async function processMedicalAid(fileUid: string, medicalCover: any, orgId: string) {
  try {
    console.log(chalk.cyan('🏥 API: Processing medical aid data'));
    
    // Find existing medical aid record for this file if any
    const existingMedicalAid = await prisma.patient_medical_aid.findFirst({
      where: {
        fileid: fileUid,
        active: true
      }
    });
    
    // Extract medical aid data
    const medicalAidData = medicalCover.medical_aid || {};
    const schemeId = medicalAidData.scheme_id;
    const membershipNumber = medicalAidData.membership_number || '';
    const dependentCode = medicalAidData.dependent_code || '';
    
    // If scheme ID is not provided, we can't proceed with creating/updating medical aid
    if (!schemeId) {
      console.log(chalk.yellow('⚠️ API: No scheme ID provided, skipping medical aid save'));
      return;
    }
    
    // Upsert medical aid record
    let medicalAidUid;
    if (existingMedicalAid) {
      // Update existing record
      console.log(chalk.yellow(`🔄 API: Updating existing medical aid with UID: ${existingMedicalAid.uid}`));
      
      await prisma.patient_medical_aid.update({
        where: { uid: existingMedicalAid.uid },
        data: {
          medical_scheme_id: schemeId,
          membership_number: membershipNumber,
          patient_dependant_code: dependentCode,
          last_edit: new Date()
        }
      });
      
      medicalAidUid = existingMedicalAid.uid;
    } else {
      // Create new record
      medicalAidUid = uuidv4();
      console.log(chalk.green(`➕ API: Creating new medical aid with UID: ${medicalAidUid}`));
      
      await prisma.patient_medical_aid.create({
        data: {
          uid: medicalAidUid,
          medical_scheme_id: schemeId,
          membership_number: membershipNumber,
          patient_dependant_code: dependentCode,
          fileid: fileUid,
          orgid: orgId,
          active: true,
          date_created: new Date(),
          last_edit: new Date()
        }
      });
    }
    
    // Handle the main member data (if "same as patient" is not checked)
    if (!medicalCover.same_as_patient && medicalCover.member) {
      await processMedicalAidMember(fileUid, medicalAidUid, medicalCover.member, orgId);
    }
    
    console.log(chalk.green('✅ API: Medical aid processing completed'));
  } catch (error) {
    console.error(chalk.red('💥 API: Error processing medical aid:'), error);
    throw error; // Re-throw to be caught by the caller
  }
}

// Helper function to process medical aid member data
async function processMedicalAidMember(fileUid: string, medicalAidUid: string, memberData: any, orgId: string) {
  try {
    console.log(chalk.cyan('👪 API: Processing medical aid member data'));
    
    // Find existing member link for this medical aid if any
    const existingLink = await prisma.patientmedicalaid_file_patient.findFirst({
      where: {
        patient_medical_aid_id: medicalAidUid,
        active: true
      },
      include: {
        patient: true
      }
    });
    
    // Parse date of birth if provided
    let dobDate = null;
    if (memberData.dob) {
      const dobParts = memberData.dob.split('/');
      if (dobParts.length === 3) {
        dobDate = new Date(
          parseInt(dobParts[0]), // Year
          parseInt(dobParts[1]) - 1, // Month (0-indexed)
          parseInt(dobParts[2]) // Day
        );
      }
    }
    
    let memberPatientUid;
    
    if (existingLink && existingLink.patient) {
      // Update existing patient record
      memberPatientUid = existingLink.patient.uid;
      console.log(chalk.yellow(`🔄 API: Updating existing member with UID: ${memberPatientUid}`));
      
      await prisma.patient.update({
        where: { uid: memberPatientUid },
        data: {
          id: memberData.id || '',
          title: memberData.title || '',
          name: memberData.name || '',
          initials: memberData.initials || '',
          surname: memberData.surname || '',
          date_of_birth: dobDate,
          gender: memberData.gender || '',
          cell_phone: memberData.cell || '',
          email: memberData.email || '',
          address: memberData.address || '',
          last_edit: new Date()
        }
      });
    } else {
      // Create new patient record for the member
      memberPatientUid = uuidv4();
      console.log(chalk.green(`➕ API: Creating new member patient with UID: ${memberPatientUid}`));
      
      await prisma.patient.create({
        data: {
          uid: memberPatientUid,
          id: memberData.id || '',
          title: memberData.title || '',
          name: memberData.name || '',
          initials: memberData.initials || '',
          surname: memberData.surname || '',
          date_of_birth: dobDate,
          gender: memberData.gender || '',
          cell_phone: memberData.cell || '',
          email: memberData.email || '',
          address: memberData.address || '',
          orgid: orgId,
          active: true,
          date_created: new Date(),
          last_edit: new Date()
        }
      });
      
      // Create new link record
      const linkUid = uuidv4();
      console.log(chalk.green(`➕ API: Creating new medical aid member link with UID: ${linkUid}`));
      
      await prisma.patientmedicalaid_file_patient.create({
        data: {
          uid: linkUid,
          patient_medical_aid_id: medicalAidUid,
          fileid: fileUid,
          patientid: memberPatientUid,
          orgid: orgId,
          active: true,
          date_created: new Date(),
          last_edit: new Date()
        }
      });
    }
    
    console.log(chalk.green('✅ API: Medical aid member processing completed'));
  } catch (error) {
    console.error(chalk.red('💥 API: Error processing medical aid member:'), error);
    throw error; // Re-throw to be caught by the caller
  }
}

// Helper function to process injury on duty data
async function processInjuryOnDuty(fileUid: string, data: any, orgId: string) {
  try {
    console.log(chalk.cyan('🏢 API: Processing injury on duty data'));
    
    // Find existing injury record for this file if any
    const existingInjury = await prisma.injury_on_duty.findFirst({
      where: {
        fileid: fileUid,
        active: true
      }
    });
    
    // Extract injury on duty data
    const injuryData = data.injury_on_duty || {};
    const companyName = injuryData.company_name || '';
    const contactPerson = injuryData.contact_person || '';
    const contactNumber = injuryData.contact_number || '';
    const contactEmail = injuryData.contact_email || '';
    
    if (existingInjury) {
      // Update existing record
      console.log(chalk.yellow(`🔄 API: Updating existing injury record with UID: ${existingInjury.uid}`));
      
      await prisma.injury_on_duty.update({
        where: { uid: existingInjury.uid },
        data: {
          company_name: companyName,
          contact_person: contactPerson,
          contact_number: contactNumber,
          contact_email: contactEmail,
          last_edit: new Date()
        }
      });
    } else {
      // Create new record
      const injuryUid = uuidv4();
      console.log(chalk.green(`➕ API: Creating new injury record with UID: ${injuryUid}`));
      
      await prisma.injury_on_duty.create({
        data: {
          uid: injuryUid,
          company_name: companyName,
          contact_person: contactPerson,
          contact_number: contactNumber,
          contact_email: contactEmail,
          fileid: fileUid,
          orgid: orgId,
          active: true,
          created_date: new Date(),
          date_created: new Date(),
          last_edit: new Date()
        }
      });
    }
    
    console.log(chalk.green('✅ API: Injury on duty processing completed'));
  } catch (error) {
    console.error(chalk.red('💥 API: Error processing injury on duty:'), error);
    throw error; // Re-throw to be caught by the caller
  }
}
</file>

<file path="app/api/files/route.ts">
import { NextResponse } from 'next/server';
import prisma from '@/app/lib/prisma';
import { auth } from '@/app/lib/auth';
import chalk from 'chalk';

export async function GET() {
  try {
    console.log(chalk.blue.bold('🔍 API: /api/files endpoint called'));
    const session = await auth();
    if (!session?.user?.orgId) {
      console.log(chalk.red('❌ API: No organization ID found in session'));
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    console.log(chalk.cyan(`🏢 API: Fetching files for organization ID: ${session.user.orgId}`));

    // Query directly from file_info table - this is the main table
    // All files should be fetched even if there is no associated patient
    const fileInfos = await prisma.file_info.findMany({
      where: { 
        active: true,
        orgid: session.user.orgId 
      },
      include: {
        // Include the relationship to patient through fileinfo_patient
        fileinfo_patient: {
          where: {
            active: true
          },
          include: {
            patient: {
              where: {
                active: true
              }
            }
          }
        }
      },
    });
    
    console.log(chalk.green(`📊 API: Raw query result count: ${fileInfos.length}`));
    
    if (fileInfos.length > 0) {
      const filesWithPatients = fileInfos.filter(f => f.fileinfo_patient.length > 0);
      const filesWithoutPatients = fileInfos.filter(f => f.fileinfo_patient.length === 0);
      
      console.log(chalk.yellow(`📄 API: Files with patients: ${filesWithPatients.length}`));
      console.log(chalk.yellow(`📄 API: Files without patients: ${filesWithoutPatients.length}`));
      
      if (fileInfos.length > 0) {
        console.log(chalk.yellow('📄 API: Sample of first file_info record:'));
        console.log(chalk.yellow(JSON.stringify({
          uid: fileInfos[0].uid,
          file_number: fileInfos[0].file_number,
          account_number: fileInfos[0].account_number,
          has_patient_relations: fileInfos[0].fileinfo_patient.length > 0
        }, null, 2)));
      }
    } else {
      console.log(chalk.yellow('📭 API: No records found'));
    }

    // Transform data to handle cases where patient info might not exist
    const files = fileInfos.map(fileInfo => {
      // Get the first linked patient if it exists
      const filePatient = fileInfo.fileinfo_patient.length > 0 ? fileInfo.fileinfo_patient[0] : null;
      const patient = filePatient?.patient || null;
      
      return {
        uid: fileInfo.uid,
        file_number: fileInfo.file_number || '',
        account_number: fileInfo.account_number || '',
        patient: {
          id: patient?.id || '',
          name: patient?.name || '',
          gender: patient?.gender || '',
        }
      };
    });
    
    console.log(chalk.green(`🔄 API: Transformed response count: ${files.length}`));
    
    if (files.length > 0) {
      const filesWithPatientInfo = files.filter(f => f.patient.id || f.patient.name);
      const filesWithoutPatientInfo = files.filter(f => !f.patient.id && !f.patient.name);
      
      console.log(chalk.magenta(`📋 API: Files with patient info: ${filesWithPatientInfo.length}`));
      console.log(chalk.magenta(`📋 API: Files without patient info: ${filesWithoutPatientInfo.length}`));
      
      if (files.length > 0) {
        console.log(chalk.magenta('📋 API: Sample of first transformed record:'));
        console.log(chalk.magenta(JSON.stringify(files[0], null, 2)));
        
        if (filesWithoutPatientInfo.length > 0) {
          console.log(chalk.magenta('📋 API: Sample of file without patient info:'));
          console.log(chalk.magenta(JSON.stringify(filesWithoutPatientInfo[0], null, 2)));
        }
      }
    } else {
      console.log(chalk.magenta('🚫 API: No records after transform'));
    }

    return NextResponse.json(files);
  } catch (error) {
    console.error(chalk.red('💥 API: Error fetching files:'), error);
    return NextResponse.json({ error: 'Failed to fetch files', files: [] }, { status: 500 });
  }
}
</file>

<file path="app/api/settings/organization/[uid]/consent/[number]/route.ts">
import { NextRequest } from 'next/server'
import { auth } from '@/app/lib/auth'
import { getSupabaseClient } from '@/app/lib/supabase'

export async function GET(
  request: NextRequest,
  { params }: { params: { uid: string; number: string } }
) {
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return new Response('Unauthorized', { status: 401 })
    }

    if (session.user.orgId !== params.uid) {
      return new Response('Forbidden', { status: 403 })
    }

    const supabase = getSupabaseClient()
    if (!supabase) {
      return new Response('Supabase client not initialized', { status: 500 })
    }

    const path = `${params.uid}/consent-forms/${params.uid}Consent${params.number}.txt`
    
    const { data, error } = await supabase.storage
      .from('DigiFile_Public')
      .download(path)

    if (error) {
      console.error('Error fetching consent file:', error)
      return new Response('File not found', { status: 404 })
    }

    const text = await data.text()
    return new Response(text, {
      headers: { 'Content-Type': 'text/plain' },
    })
  } catch (error) {
    console.error('Error processing consent request:', error)
    return new Response('Internal Server Error', { status: 500 })
  }
}
</file>

<file path="app/api/settings/organization/[uid]/logo/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { getSupabaseClient } from '@/app/lib/supabase'
import { auth } from '@/app/lib/auth'

export async function PUT(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  const supabase = getSupabaseClient()
  if (!supabase) {
    return NextResponse.json({ error: 'Supabase client not initialized' }, { status: 500 })
  }

  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized - No organization ID found' },
        { status: 401 }
      )
    }

    // Verify the requested org matches the session org
    if (session.user.orgId !== params.uid) {
      return NextResponse.json(
        { error: 'Unauthorized - Organization mismatch' },
        { status: 403 }
      )
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    if (!file) {
      return NextResponse.json(
        { error: 'No file provided' },
        { status: 400 }
      )
    }

    // Upload to Supabase
    const { error: uploadError } = await supabase.storage
      .from('DigiFile_Public')
      .upload(`${params.uid}/logo/${params.uid}-logo.jpg`, file, {
        upsert: true,
        contentType: 'image/jpeg'
      })

    if (uploadError) {
      console.error('Supabase upload error:', uploadError)
      return NextResponse.json(
        { error: 'Failed to upload logo' },
        { status: 500 }
      )
    }

    // Get the public URL
    const { data: urlData } = supabase.storage
      .from('DigiFile_Public')
      .getPublicUrl(`${params.uid}/logo/${params.uid}-logo.jpg`)

    return NextResponse.json({ url: urlData.publicUrl })
  } catch (error) {
    console.error('Logo upload error:', error)
    return NextResponse.json(
      { error: 'Failed to process logo upload' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/settings/users/roles/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

// Get all available roles for the organization
export async function GET() {
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    console.log("[api/settings/users/roles] Getting all roles for organization " + session.user.orgId);
    // Fetch all roles for the organization
    const roles = await prisma.roles.findMany({
      where: {
        active: true
      },
      select: {
        uid: true,
        role_name: true,
        description: true
      }
    })

    console.log("[api/settings/users/roles] Roles found:", roles)

    return NextResponse.json(roles)
  } catch (error) {
    console.error('Failed to fetch roles:', error)
    return NextResponse.json(
      { error: 'Failed to fetch roles' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/components/ui/account-selector/account-selector.tsx">
import { Account } from "@/app/types/calendar"
import { Button } from "@/app/components/ui/button"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/app/components/ui/dialog"
import { AccountList } from "./account-list"

interface AccountSelectorProps {
  accounts: Account[]
  selectedAccounts: string[]
  onToggleAccount: (accountId: string) => void
  onAddAccount: (account: Account) => void
}

export function AccountSelector({
  accounts,
  selectedAccounts,
  onToggleAccount,
}: AccountSelectorProps) {
  return (
    <div className="flex items-center gap-4 w-full border rounded-lg p-2 bg-white">
      <Dialog>
        <DialogTrigger asChild>
          <Button 
            variant="outline" 
            className="shrink-0"
            disabled={selectedAccounts.length >= 51}
          >
            Add Account
          </Button>
        </DialogTrigger>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Select Accounts</DialogTitle>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            {accounts.map((account) => (
              <div key={account.AccountID} className="flex items-center gap-4">
                <input
                  type="checkbox"
                  id={account.AccountID}
                  checked={selectedAccounts.includes(account.AccountID)}
                  onChange={() => onToggleAccount(account.AccountID)}
                  className="h-4 w-4 rounded border-gray-300"
                  disabled={!selectedAccounts.includes(account.AccountID) && selectedAccounts.length >= 51}
                />
                <label htmlFor={account.AccountID} className="text-sm font-medium">
                  {account.Name}
                </label>
              </div>
            ))}
          </div>
        </DialogContent>
      </Dialog>
      <AccountList
        accounts={accounts}
        selectedAccounts={selectedAccounts}
        onRemoveAccount={onToggleAccount}
      />
    </div>
  )
}
</file>

<file path="app/components/ui/collapsible-sidebar.tsx">
'use client'

import * as React from 'react'
import { Home, FileText, Settings, Menu, Calendar } from 'lucide-react'
import { cn } from "@/app/lib/utils"
import { Button } from "@/app/components/ui/button"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/app/components/ui/tooltip"
import {
  Sidebar,
  SidebarContent,
  SidebarTrigger,
  SidebarHeader,
  SidebarFooter,
  SidebarProvider,
  useSidebar
} from "@/app/components/ui/sidebar"

const navItems = [
  { name: 'Home', icon: Home, href: '/sites' },
  { name: 'File Data', icon: FileText, href: '/sites/file-data' },
  { name: 'Calendar', icon: Calendar, href: '/sites/calendar' },
  { name: 'Settings', icon: Settings, href: '/sites/settings' },
]

function SidebarWrapper() {
  const { state, toggle } = useSidebar()
  const isCollapsed = state === 'collapsed'
  
  console.log('SidebarWrapper rendered, state:', state)

  return (
    <Sidebar collapsible="icon" className="border-r">
      <SidebarHeader className="flex items-center p-2">
        <SidebarTrigger onClick={toggle} className="h-8 w-8">
          <Menu className="h-5 w-5" />
        </SidebarTrigger>
      </SidebarHeader>
      <SidebarContent className="flex flex-col gap-2 px-1 py-4">
        {navItems.map((item) => (
          <Tooltip key={item.name} delayDuration={0}>
            <TooltipTrigger asChild>
              <Button
                variant="ghost"
                className={cn(
                  "w-full",
                  isCollapsed ? "h-8 w-8 p-0 justify-center" : "px-2 justify-start"
                )}
                asChild
              >
                <a href={item.href} className={cn(
                  "flex items-center gap-2",
                  isCollapsed ? "justify-center" : "justify-start w-full"
                )}>
                  <item.icon className="h-5 w-5 shrink-0" />
                  {!isCollapsed && <span>{item.name}</span>}
                </a>
              </Button>
            </TooltipTrigger>
            {isCollapsed && (
              <TooltipContent side="right" className="ml-1">
                {item.name}
              </TooltipContent>
            )}
          </Tooltip>
        ))}
      </SidebarContent>
      <SidebarFooter className="p-2">
        {!isCollapsed && <span className="text-sm text-muted-foreground">Login Here</span>}
      </SidebarFooter>
    </Sidebar>
  )
}

export function CollapsibleSidebar() {
  return (
    <TooltipProvider>
      <SidebarProvider>
        <SidebarWrapper />
      </SidebarProvider>
    </TooltipProvider>
  )
}
</file>

<file path="app/components/ui/consent-modal.tsx">
'use client'

import { useState, useEffect } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from './dialog'
import { ScrollArea } from './scroll-area'

type ConsentModalProps = {
  isOpen: boolean
  onClose: () => void
  consentNumber: number
  orgId: string
}

export function ConsentModal({ isOpen, onClose, consentNumber, orgId }: ConsentModalProps) {
  const [content, setContent] = useState<string>('')
  const [error, setError] = useState<string | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchConsentContent = async () => {
      if (!isOpen) return
      
      try {
        setIsLoading(true)
        setError(null)
        
        const response = await fetch(`/api/settings/organization/${orgId}/consent/${consentNumber}`)
        if (!response.ok) {
          throw new Error('Failed to fetch consent document')
        }
        
        const text = await response.text()
        setContent(text)
      } catch (error) {
        console.error('Error fetching consent content:', error)
        setError('Failed to load consent document')
      } finally {
        setIsLoading(false)
      }
    }

    fetchConsentContent()
  }, [isOpen, consentNumber, orgId])

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl">
        <DialogHeader>
          <DialogTitle>Consent Document {consentNumber}</DialogTitle>
        </DialogHeader>
        <ScrollArea className="h-[60vh] w-full p-4">
          {isLoading ? (
            <div className="flex justify-center">Loading...</div>
          ) : error ? (
            <div className="text-red-500">{error}</div>
          ) : (
            <pre className="whitespace-pre-wrap font-sans">{content}</pre>
          )}
        </ScrollArea>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="app/components/ui/header.tsx">
import { auth } from "@/app/lib/auth"
import { ClientHeader } from "@/app/components/ui/client-header"

export async function Header() {
  const session = await auth()
  
  return <ClientHeader session={session} />
}
</file>

<file path="app/components/ui/input.tsx">
"use client"

import React from "react"

export function Input({ ...props }: React.InputHTMLAttributes<HTMLInputElement>) {
  return <input {...props} className={`w-full p-2 border rounded ${props.className}`} />
}
</file>

<file path="app/components/ui/label.tsx">
"use client"

import React from "react"

export function Label({ ...props }: React.LabelHTMLAttributes<HTMLLabelElement>) {
  return <label {...props} className={`block mb-1 font-medium ${props.className}`} />
}
</file>

<file path="app/hooks/use-session.ts">
'use client'

import { useState, useEffect } from 'react'
import { getSessionData } from '@/app/actions/auth'
import type { Session } from 'next-auth'
import { config } from '@/app/lib/config'

export const useSession = () => {
  const [session, setSession] = useState<Session | null>(null)
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const loadSession = async () => {
      try {
        const data = await getSessionData()
        
        if (!data) {
          setSession(null)
          return
        }

        const sessionData: Session | null = {
          expires: new Date(Date.now() + config.sessionTimeout).toISOString(),
          user: {
            orgId: data.user.orgId,
            roles: data.user.roles || [],
            name: data.user.name || null,
            email: data.user.email || null,
          },
        }
        setSession(sessionData)
      } catch (error) {
        console.error('Error loading session:', error)
        setSession(null)
      } finally {
        setIsLoading(false)
      }
    }

    loadSession()
  }, [])

  return {
    session,
    isLoading
  }
}
</file>

<file path="app/lib/config.ts">
export const config = {
  sessionTimeout: 30 * 60 * 1000, // 30 minutes in milliseconds
  titles: [
    { value: 'Mr', label: 'Mr' },
    { value: 'Mrs', label: 'Mrs' },
    { value: 'Ms', label: 'Ms' },
    { value: 'Dr', label: 'Dr' },
    { value: 'Prof', label: 'Prof' }
  ]
};
</file>

<file path="app/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

export function toUTCDate(date: Date | string): Date {
  const d = new Date(date);
  return new Date(Date.UTC(
    d.getUTCFullYear(),
    d.getUTCMonth(),
    d.getUTCDate(),
    d.getUTCHours(),
    d.getUTCMinutes(),
    d.getUTCSeconds()
  ));
}

export function formatTimeToLocal(date: Date | string): string {
  return new Date(date).toLocaleTimeString('en-US', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: true,
    timeZone: 'UTC'
  });
}
</file>

<file path="app/login/registration/contact-details-form.tsx">
'use client'

import { Input } from "@/app/components/ui/input"
import { Label } from "@/app/components/ui/label"

interface ContactDetailsFormProps {
  value: {
    practiceTelephone?: string;
    accountsTelephone?: string;
    postalCode?: string;
    fullAddress?: string;
    practiceEmail?: string;
    cellNumber?: string;
    fax?: string;
  };
  onChange: (value: ContactDetailsFormProps['value']) => void;
}

export function ContactDetailsForm({ value, onChange }: ContactDetailsFormProps) {
  const handleInputChange = (field: keyof typeof value) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    onChange({
      ...value,
      [field]: e.target.value,
    });
  };

  return (
    <div className="space-y-6 p-4">
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="grid gap-2">
          <Label htmlFor="practiceTelephone">Practice Telephone Number</Label>
          <Input 
            id="practiceTelephone" 
            placeholder="Enter practice telephone"
            value={value.practiceTelephone || ''}
            onChange={handleInputChange('practiceTelephone')}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="accountsTelephone">Accounts Telephone Number</Label>
          <Input 
            id="accountsTelephone" 
            placeholder="Enter accounts telephone"
            value={value.accountsTelephone || ''}
            onChange={handleInputChange('accountsTelephone')}
          />
        </div>

        <div className="grid gap-2">
          <Label htmlFor="postalCode">Postal Code</Label>
          <Input 
            id="postalCode" 
            placeholder="Enter postal code"
            value={value.postalCode || ''}
            onChange={handleInputChange('postalCode')}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="fullAddress">Full Address</Label>
          <Input 
            id="fullAddress" 
            placeholder="Enter full address"
            value={value.fullAddress || ''}
            onChange={handleInputChange('fullAddress')}
          />
        </div>

        <div className="grid gap-2">
          <Label htmlFor="practiceEmail">Practice Email</Label>
          <Input 
            id="practiceEmail" 
            type="email" 
            placeholder="Enter practice email"
            value={value.practiceEmail || ''}
            onChange={handleInputChange('practiceEmail')}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="cellNumber">Cell Number</Label>
          <Input 
            id="cellNumber" 
            placeholder="Enter cell number"
            value={value.cellNumber || ''}
            onChange={handleInputChange('cellNumber')}
          />
        </div>
      </div>

      <div className="grid gap-2">
        <Label htmlFor="fax">Fax</Label>
        <Input 
          id="fax" 
          placeholder="Enter fax number"
          value={value.fax || ''}
          onChange={handleInputChange('fax')}
        />
      </div>
    </div>
  )
}
</file>

<file path="app/login/registration/extra-info-form.tsx">
'use client'

import { useState, useRef } from 'react'
import Image from 'next/image'
import { Button } from "@/app/components/ui/button"
import { ConsentRow } from './components/consent-row'

interface ConsentFile {
  content: string | null
}

interface ExtraInfoFormProps {
  value: {
    logo: string | null;
    consents: { content: string | null }[];
  };
  onChange: (value: ExtraInfoFormProps['value']) => void;
}

export function ExtraInfoForm({ value, onChange }: ExtraInfoFormProps) {
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleLogoUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        onChange({
          ...value,
          logo: reader.result as string,
        });
      }
      reader.readAsDataURL(file)
    }
  }

  const handleConsentUpload = (index: number) => async (file: File) => {
    const text = await file.text()
    const updatedConsents = [...value.consents]
    updatedConsents[index] = { content: text }
    onChange({
      ...value,
      consents: updatedConsents,
    });
  }

  return (
    <div className="space-y-8 p-4">
      {/* Logo Section */}
      <div className="flex justify-end items-center gap-4">
        <div className="h-32 w-32 border rounded-lg flex items-center justify-center bg-muted">
          {value.logo ? (
            <Image
              src={value.logo}
              alt="Practice Logo"
              width={120}
              height={120}
              className="object-contain"
            />
          ) : (
            <p className="text-muted-foreground text-sm">No logo uploaded</p>
          )}
        </div>
        <div>
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleLogoUpload}
            accept="image/*"
            className="hidden"
          />
          <Button 
            onClick={() => fileInputRef.current?.click()}
          >
            {value.logo ? 'Change Logo' : 'Upload Logo'}
          </Button>
        </div>
      </div>

      {/* Consent Sections */}
      <div className="space-y-6">
        {value.consents.map((consent, index) => (
          <ConsentRow
            key={index}
            number={index + 1}
            content={consent.content}
            onUpload={handleConsentUpload(index)}
          />
        ))}
      </div>
    </div>
  )
}
</file>

<file path="app/login/registration/page.tsx">
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/app/components/ui/tabs"
import { Button } from "@/app/components/ui/button"
import { PracticeInfoForm } from './practice-info-form'
import { ContactDetailsForm } from './contact-details-form'
import { UserCreationForm } from './user-creation-form'
import { ExtraInfoForm } from './extra-info-form'
import { VerificationModal } from './components/verification-modal'
import { z } from "zod";

const practiceInfoSchema = z.object({
  practiceName: z.string().min(1, "Practice name is required"),
  bhfNumber: z.string().min(1, "BHF number is required").regex(/^\d+$/, "BHF number must contain only numbers"),
  hpcsaNumber: z.string().optional(),
  practiceType: z.string().optional(),
  vatNumber: z.string().optional(),
});

const userCreationSchema = z.object({
  firstName: z.string().min(1, "First name is required"),
  lastName: z.string().min(1, "Last name is required"),
  username: z.string().min(1, "Username is required"),
  password: z.string().min(8, "Password must be at least 8 characters"),
  confirmPassword: z.string(),
}).refine((data) => data.password === data.confirmPassword, {
  message: "Passwords don't match",
  path: ["confirmPassword"],
});

interface FormData {
  practiceInfo: z.infer<typeof practiceInfoSchema>;
  contactDetails: {
    practiceTelephone?: string;
    accountsTelephone?: string;
    postalCode?: string;
    fullAddress?: string;
    practiceEmail?: string;
    cellNumber?: string;
    fax?: string;
  };
  userCreation: {
    title?: string;
    initials?: string;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    confirmPassword: string;
    signature: string | null;
    hpcsa?: string;
    cellNumber?: string;
  };
  extraInfo: {
    logo: string | null;
    consents: { content: string | null }[];
  };
}

export default function RegistrationPage() {
  const router = useRouter()
  const [activeTab, setActiveTab] = useState("practice-info")
  const [showVerificationModal, setShowVerificationModal] = useState(false)
  const [formData, setFormData] = useState<FormData>({
    practiceInfo: {
      practiceName: '',
      bhfNumber: '',
      hpcsaNumber: '',
      practiceType: '',
      vatNumber: '',
    },
    contactDetails: {
      practiceTelephone: '',
      accountsTelephone: '',
      postalCode: '',
      fullAddress: '',
      practiceEmail: '',
      cellNumber: '',
      fax: '',
    },
    userCreation: {
      title: '',
      initials: '',
      firstName: '',
      lastName: '',
      username: '',
      password: '',
      confirmPassword: '',
      signature: null,
      hpcsa: '',
      cellNumber: '',
    },
    extraInfo: {
      logo: null,
      consents: [
        { content: null },
        { content: null },
        { content: null }
      ],
    },
  });
  const [errors, setErrors] = useState<{ [key: string]: string[] }>({});
  
  const tabs = [
    { id: "practice-info", label: "Practice Info" },
    { id: "contact-details", label: "Contact Details" },
    { id: "user-creation", label: "User Creation" },
    { id: "extra-info", label: "Extra Info" },
  ]

  const isLastTab = activeTab === tabs[tabs.length - 1].id

  const isFormValid = () => {
    try {
      if (activeTab === "practice-info" || activeTab === "extra-info") {
        practiceInfoSchema.parse(formData.practiceInfo);
      }
      if (activeTab === "user-creation" || activeTab === "extra-info") {
        userCreationSchema.parse(formData.userCreation);
      }
      return true;
    } catch (error) {
      return false;
    }
  };

  const handleNext = async () => {
    if (isLastTab) {
      try {
        // Validate all required data
        const validatedPracticeInfo = practiceInfoSchema.parse(formData.practiceInfo);
        const validatedUserCreation = userCreationSchema.parse(formData.userCreation);

        // If validation passes, show verification modal
        setShowVerificationModal(true);
      } catch (error) {
        if (error instanceof z.ZodError) {
          setErrors(error.flatten().fieldErrors);
          
          // Find the tab with errors and switch to it
          const errorFields = Object.keys(error.flatten().fieldErrors);
          const practiceInfoFields = ['practiceName', 'bhfNumber', 'hpcsaNumber', 'practiceType', 'vatNumber'];
          const userCreationFields = ['firstName', 'lastName', 'username', 'password', 'confirmPassword'];

          if (errorFields.some(field => practiceInfoFields.includes(field))) {
            setActiveTab("practice-info");
          } else if (errorFields.some(field => userCreationFields.includes(field))) {
            setActiveTab("user-creation");
          }
        }
      }
    } else {
      const currentIndex = tabs.findIndex(tab => tab.id === activeTab);
      if (currentIndex < tabs.length - 1) {
        // Validate current tab before moving to next
        try {
          if (activeTab === "practice-info") {
            practiceInfoSchema.parse(formData.practiceInfo);
          } else if (activeTab === "user-creation") {
            userCreationSchema.parse(formData.userCreation);
          }
          setActiveTab(tabs[currentIndex + 1].id);
        } catch (error) {
          if (error instanceof z.ZodError) {
            setErrors(error.flatten().fieldErrors);
          }
        }
      }
    }
  };

  const handlePrevious = () => {
    const currentIndex = tabs.findIndex(tab => tab.id === activeTab)
    if (currentIndex > 0) {
      setActiveTab(tabs[currentIndex - 1].id)
    }
  }

  const handleCancel = () => {
    router.push('/login/signin')
  }

  const handleVerificationSubmit = async () => {
    try {
      // Validate practice info
      const validatedPracticeInfo = practiceInfoSchema.parse(formData.practiceInfo);
      const validatedUserCreation = userCreationSchema.parse(formData.userCreation);

      // If validation passes, submit to API
      const response = await fetch('/api/register', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(formData),
      });

      if (!response.ok) {
        throw new Error('Registration failed');
      }

      setShowVerificationModal(false);
      router.push('/success');
    } catch (error) {
      if (error instanceof z.ZodError) {
        setErrors(error.flatten().fieldErrors);
      } else {
        console.error('Registration error:', error);
      }
    }
  };

  return (
    <div className="container mx-auto py-6 space-y-8">
      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full grid-cols-4">
          {tabs.map((tab) => (
            <TabsTrigger 
              key={tab.id} 
              value={tab.id}
              className={
                tab.id === "practice-info" && !isFormValid && activeTab === "extra-info"
                  ? "border-red-500 border-2"
                  : ""
              }
            >
              {tab.label}
            </TabsTrigger>
          ))}
        </TabsList>
        <TabsContent value="practice-info">
          <PracticeInfoForm 
            value={formData.practiceInfo}
            onChange={(value) => setFormData(prev => ({ ...prev, practiceInfo: value }))}
            errors={errors}
          />
        </TabsContent>
        <TabsContent value="contact-details">
          <ContactDetailsForm 
            value={formData.contactDetails}
            onChange={(value) => setFormData(prev => ({ ...prev, contactDetails: value }))}
          />
        </TabsContent>
        <TabsContent value="user-creation">
          <UserCreationForm 
            value={formData.userCreation}
            onChange={(value) => setFormData(prev => ({ ...prev, userCreation: value }))}
            errors={errors}
          />
        </TabsContent>
        <TabsContent value="extra-info">
          <ExtraInfoForm 
            value={formData.extraInfo}
            onChange={(value) => setFormData(prev => ({ ...prev, extraInfo: value }))}
          />
        </TabsContent>
      </Tabs>

      <div className="flex justify-end gap-4">
        <Button variant="destructive" onClick={handleCancel}>
          Cancel
        </Button>
        <Button 
          variant="secondary" 
          onClick={handlePrevious}
          disabled={activeTab === tabs[0].id}
        >
          Previous
        </Button>
        <Button 
          onClick={handleNext}
          disabled={isLastTab && !isFormValid()}
        >
          {isLastTab ? 'Finish' : 'Next'}
        </Button>
      </div>

      <VerificationModal
        isOpen={showVerificationModal}
        onClose={() => setShowVerificationModal(false)}
        onSubmit={handleVerificationSubmit}
      />
    </div>
  )
}
</file>

<file path="app/login/registration/user-creation-form.tsx">
'use client'

import { useState, useRef } from 'react'
import Image from 'next/image'
import { Input } from "@/app/components/ui/input"
import { Label } from "@/app/components/ui/label"
import { Button } from "@/app/components/ui/button"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/app/components/ui/select"
import { Eye, EyeOff } from 'lucide-react'

interface UserCreationFormProps {
  value: {
    title?: string;
    initials?: string;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    confirmPassword: string;
    signature: string | null;
    hpcsa?: string;
    cellNumber?: string;
  };
  onChange: (value: UserCreationFormProps['value']) => void;
  errors?: { [key: string]: string[] };
}

export function UserCreationForm({ value, onChange, errors }: UserCreationFormProps) {
  const [showPassword, setShowPassword] = useState(false)
  const [showConfirmPassword, setShowConfirmPassword] = useState(false)
  const fileInputRef = useRef<HTMLInputElement>(null)

  const handleInputChange = (field: keyof typeof value) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    onChange({
      ...value,
      [field]: e.target.value,
    });
  };

  const handleSignatureUpload = (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0]
    if (file) {
      const reader = new FileReader()
      reader.onloadend = () => {
        onChange({
          ...value,
          signature: reader.result as string,
        });
      }
      reader.readAsDataURL(file)
    }
  };

  const hasMinLength = (pass: string) => pass.length >= 8
  const hasUpperCase = (pass: string) => /[A-Z]/.test(pass)
  const hasNumber = (pass: string) => /[0-9]/.test(pass)
  const hasSpecialChar = (pass: string) => /[!@#$%^&*(),.?":{}|<>]/.test(pass)

  const passwordRequirements = [
    { text: 'At least 8 characters long', valid: hasMinLength(value.password) },
    { text: 'Contains at least one uppercase letter', valid: hasUpperCase(value.password) },
    { text: 'Contains at least one number', valid: hasNumber(value.password) },
    { text: 'Contains at least one special character', valid: hasSpecialChar(value.password) }
  ]

  return (
    <div className="space-y-6 p-4">
      {/* Row 1 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="grid gap-2">
          <Label htmlFor="title">Title</Label>
          <Select
            value={value.title}
            onValueChange={(newValue) => onChange({ ...value, title: newValue })}
          >
            <SelectTrigger id="title">
              <SelectValue placeholder="Select title" />
            </SelectTrigger>
            <SelectContent>
              <SelectItem value="mr">Mr</SelectItem>
              <SelectItem value="mrs">Mrs</SelectItem>
            </SelectContent>
          </Select>
        </div>
        <div className="grid gap-2">
          <Label htmlFor="initials">Initials</Label>
          <Input 
            id="initials" 
            placeholder="Enter initials"
            value={value.initials || ''}
            onChange={handleInputChange('initials')}
          />
        </div>
      </div>

      {/* Row 2 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="grid gap-2">
          <Label htmlFor="firstName">First Name</Label>
          <Input 
            id="firstName" 
            placeholder="Enter first name"
            value={value.firstName}
            onChange={handleInputChange('firstName')}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="lastName">Last Name</Label>
          <Input 
            id="lastName" 
            placeholder="Enter last name"
            value={value.lastName}
            onChange={handleInputChange('lastName')}
          />
        </div>
      </div>

      {/* Row 3 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div className="grid gap-2">
          <Label htmlFor="hpcsa">HPCSA</Label>
          <Input 
            id="hpcsa" 
            placeholder="Enter HPCSA number"
            value={value.hpcsa || ''}
            onChange={handleInputChange('hpcsa')}
          />
        </div>
        <div className="grid gap-2">
          <Label htmlFor="cellNumber">Cell Number</Label>
          <Input 
            id="cellNumber" 
            placeholder="Enter cell number"
            value={value.cellNumber || ''}
            onChange={handleInputChange('cellNumber')}
          />
        </div>
      </div>

      {/* Row 4 */}
      <div className="grid gap-2">
        <Label htmlFor="username">Username</Label>
        <Input 
          id="username" 
          placeholder="Enter username"
          value={value.username}
          onChange={handleInputChange('username')}
        />
      </div>

      {/* Row 5 */}
      <div className="grid gap-2">
        <Label htmlFor="password">Password</Label>
        <div className="relative">
          <Input 
            id="password" 
            type={showPassword ? "text" : "password"}
            placeholder="Enter password"
            value={value.password}
            onChange={handleInputChange('password')}
          />
          <button
            type="button"
            onClick={() => setShowPassword(!showPassword)}
            className="absolute right-3 top-1/2 -translate-y-1/2"
          >
            {showPassword ? (
              <EyeOff className="h-4 w-4 text-gray-500" />
            ) : (
              <Eye className="h-4 w-4 text-gray-500" />
            )}
          </button>
        </div>
        <ul className="text-sm text-muted-foreground ml-2 list-disc list-inside">
          {passwordRequirements.map((req, index) => (
            <li 
              key={index}
              className={value.password ? (req.valid ? 'text-green-600' : 'text-red-600') : ''}
            >
              {req.text}
            </li>
          ))}
        </ul>
      </div>

      {/* Row 6 */}
      <div className="grid gap-2">
        <Label htmlFor="confirmPassword">Re-enter Password</Label>
        <div className="relative">
          <Input 
            id="confirmPassword" 
            type={showConfirmPassword ? "text" : "password"}
            placeholder="Confirm password"
            value={value.confirmPassword}
            onChange={handleInputChange('confirmPassword')}
          />
          <button
            type="button"
            onClick={() => setShowConfirmPassword(!showConfirmPassword)}
            className="absolute right-3 top-1/2 -translate-y-1/2"
          >
            {showConfirmPassword ? (
              <EyeOff className="h-4 w-4 text-gray-500" />
            ) : (
              <Eye className="h-4 w-4 text-gray-500" />
            )}
          </button>
        </div>
        {value.confirmPassword && (
          <p className={`text-sm ${value.password === value.confirmPassword ? 'text-green-600' : 'text-red-600'}`}>
            {value.password === value.confirmPassword ? 'Passwords match' : 'Passwords do not match'}
          </p>
        )}
      </div>

      {/* Row 7 */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6 items-center">
        <div className="grid gap-2">
          <Label>Signature</Label>
          <div className="border rounded-lg h-32 flex items-center justify-center bg-muted">
            {value.signature ? (
              <Image
                src={value.signature}
                alt="Signature"
                width={200}
                height={100}
                className="object-contain"
              />
            ) : (
              <p className="text-muted-foreground">No signature uploaded</p>
            )}
          </div>
        </div>
        <div className="grid gap-2">
          <input
            type="file"
            ref={fileInputRef}
            onChange={handleSignatureUpload}
            accept="image/*"
            className="hidden"
          />
          <Button 
            onClick={() => fileInputRef.current?.click()}
            className="w-full"
          >
            Upload Signature
          </Button>
        </div>
      </div>
    </div>
  )
}
</file>

<file path="app/sites/file-data/[uid]/layout.tsx">
'use client';

import { useState, useEffect } from 'react';
import { usePathname, useParams } from 'next/navigation';
import { ArrowLeft, Save } from 'lucide-react';
import { Button } from '@/app/components/ui/button';
import Link from 'next/link';

export default function FileDataLayout({ children }) {
  const pathname = usePathname();
  const params = useParams();
  const [headerData, setHeaderData] = useState(null);
  const [isSaving, setIsSaving] = useState(false);
  
  // Check if we're on a file detail page
  const isDetailPage = pathname.includes('/file-data/') && params.uid !== 'new-record';
  const isNewRecord = params.uid === 'new-record';
  
  // Set up event listener for header data
  useEffect(() => {
    // Function to handle the custom event
    const handleHeaderData = (event) => {
      setHeaderData(event.detail);
    };
    
    // Listen for the custom event
    window.addEventListener('file-header-data', handleHeaderData);
    
    // Clean up the event listener
    return () => {
      window.removeEventListener('file-header-data', handleHeaderData);
    };
  }, []);
  
  // Function to handle save button click
  const handleSave = () => {
    // Dispatch an event for the page to handle
    window.dispatchEvent(new Event('file-save-triggered'));
    setIsSaving(true);
    
    // Reset saving state after a delay
    setTimeout(() => setIsSaving(false), 2000);
  };
  
  return (
    <div className="flex flex-col h-screen">
      {/* Header Bar */}
      {(isDetailPage || isNewRecord) && (
        <div className="p-4 border-b flex justify-between items-center bg-white">
          <div className="flex items-center">
            <Link href="/sites/file-data" className="flex items-center mr-6 text-gray-600 hover:text-gray-900">
              <ArrowLeft size={16} className="mr-1" />
              <span>Back</span>
            </Link>
          </div>
          
          {headerData && (
            <div className="flex items-center gap-8">
              <div className="flex items-center gap-2">
                <span className="text-gray-500">File Number:</span>
                <span className="font-medium">{headerData.fileNumber || '-'}</span>
              </div>
              <div className="flex items-center gap-2">
                <span className="text-gray-500">Account Number:</span>
                <span className="font-medium">{headerData.accountNumber || '-'}</span>
              </div>
            </div>
          )}
          
          <Button 
            onClick={handleSave} 
            disabled={isSaving}
            className="flex items-center gap-2"
          >
            <Save size={16} />
            {isSaving ? 'Saving...' : 'Save'}
          </Button>
        </div>
      )}
      
      {/* Main Content */}
      <div className="flex-1 overflow-auto">
        {children}
      </div>
    </div>
  );
}
</file>

<file path="app/globals.css">
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}
</file>

<file path="Helperfiles/.database_rules">
<DATABASE INSTRUCTIONS>
# Prisma Database Guidelines for Next.js 15 Project

## 1. Database Connection Management
```typescript
// ALWAYS use this singleton pattern in lib/prisma.ts
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare global {
  var prisma: undefined | ReturnType<typeof prismaClientSingleton>
}

const prisma = globalThis.prisma ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prisma = prisma
```

## 2. Schema Rules
- Always use meaningful and clear model names in PascalCase
- Include comprehensive field comments for documentation
- Define appropriate field types and constraints
- Use explicit relations with referential actions
- Include timestamps (createdAt, updatedAt) on all models
- Use enums for fixed sets of values

Example Schema Pattern:
```prisma
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  // Relations
  posts     Post[]
  
  @@map("users") // Use snake_case for table names
}
```

## 3. Security Requirements
- NEVER expose Prisma Client in client components
- ALWAYS validate input data before queries
- Use parameter binding, NEVER string interpolation
- Implement proper error handling
- Use appropriate access modifiers
- Handle sensitive data with care

## 4. Query Patterns
### DO:
```typescript
// Use select to specify needed fields
const user = await prisma.user.findUnique({
  where: { id },
  select: {
    id: true,
    name: true,
    email: true
  }
})

// Use include for relations when needed
const post = await prisma.post.findUnique({
  where: { id },
  include: {
    author: {
      select: {
        name: true
      }
    }
  }
})
```

### DON'T:
```typescript
// ❌ Never use string interpolation
const users = await prisma.user.findMany({
  where: {
    email: `${userInput}` // SECURITY RISK
  }
})

// ❌ Avoid fetching unnecessary data
const user = await prisma.user.findMany({
  include: {
    posts: true,
    comments: true,
    likes: true
  }
})
```

## 5. Error Handling Pattern
```typescript
try {
  const result = await prisma.user.create({
    data: userData
  })
  return result
} catch (error) {
  if (error instanceof Prisma.PrismaClientKnownRequestError) {
    // Handle known Prisma errors
    if (error.code === 'P2002') {
      throw new Error('Unique constraint violation')
    }
  }
  throw error
}
```

## 6. Server Component Integration
```typescript
// Use in Server Components only
async function UserProfile({ userId }: { userId: string }) {
  const user = await prisma.user.findUnique({
    where: { id: userId }
  })
  
  if (!user) {
    throw new Error('User not found')
  }
  
  return <div>{user.name}</div>
}
```

## 7. API Route Integration
```typescript
// pages/api/users.ts
import { NextResponse } from 'next/server'
import prisma from '@/lib/prisma'

export async function GET() {
  try {
    const users = await prisma.user.findMany()
    return NextResponse.json(users)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    )
  }
}
```

## 8. Performance Guidelines
- Use appropriate indexes in schema
- Implement pagination for large datasets
- Use cursor-based pagination for real-time data
- Batch operations when possible
- Optimize includes and selects
- Use transactions for related operations

## 9. Migration Rules
- Never edit the migration files directly
- Always review migration files before applying
- Use descriptive names for migrations
- Test migrations in development first
- Backup database before production migrations
- Document breaking changes

## 10. Type Safety Requirements
- Always use generated types from Prisma Client
- Maintain strict TypeScript configuration
- Define proper input validation schemas (e.g., with Zod)
- Use type inference where possible

## 11. Environment Setup
```env
# Required in .env
DATABASE_URL="postgresql://..."

# Required in .env.local for development
SHADOW_DATABASE_URL="postgresql://..."
```

## 12. Testing Guidelines
- Use a separate test database
- Reset database state between tests
- Mock Prisma Client in unit tests
- Use transactions in integration tests
- Test error conditions and edge cases

## 13. Maintenance Rules
- Regular schema updates and migrations
- Monitor query performance
- Update Prisma dependencies regularly
- Maintain documentation
- Review and optimize indexes
- Regular database backups

## 14. Code Organization
```plaintext
project/
├── prisma/
│   ├── schema.prisma
│   ├── migrations/
│   └── seed.ts
├── lib/
│   └── prisma.ts
├── types/
│   └── prisma.d.ts
└── app/
    └── api/
        └── prisma-routes/
```
</DATABASE_INSTRUCTIONS>



## Organization Data Separation Rule
When working with multi-tenant databases:
1. Every database query MUST include the orgid filter in the WHERE clause
2. Store ORGANIZATION_ID in environment variables
3. Use AND conditions to combine orgid with other filters
4. Apply this rule to all API routes and database operations
5. Never expose organization data across tenants
</file>

<file path="Helperfiles/infopacket.txt">
require('dotenv').config();  
const express = require('express');  
const axios = require('axios');  
const fs = require('fs');  
const path = require('path');  
const { createClient } = require('@supabase/supabase-js');  

const app = express();  

// 1) Load environment variables  
const supabaseUrl = process.env.SUPABASE_URL;  
const supabaseKey = process.env.SUPABASE_ANON_KEY;  

// 2) Initialize Supabase client  
const supabase = createClient(supabaseUrl, supabaseKey);  

// 3) Simple route: lists buckets and displays an image  
app.get('/', async (req, res) => {  
  try {  
    // --------------------------------------------------  
    // (a) List all buckets  
    // --------------------------------------------------  
    const { data: buckets, error: bucketErr } = await supabase.storage.listBuckets();  
    if (bucketErr) throw bucketErr;  

    let bucketsReport;  
    if (!buckets || buckets.length === 0) {  
      bucketsReport = "No buckets found.";  
    } else {  
      bucketsReport = buckets.map(  
        (bucket, idx) => `Bucket #${idx + 1}: ${bucket.name} (ID: ${bucket.id})`  
      ).join('<br>');  
    }  

    // --------------------------------------------------  
    // (b) Get public URL for "3.jpg" from "DigiFile_Storage" bucket  
    // --------------------------------------------------  
    const { data: publicData, error: urlError } =   
      supabase.storage.from('DigiFile_Storage').getPublicUrl('7771231237130/3.jpg');  
    if (urlError) throw urlError;  

    const publicImageUrl = publicData.publicUrl;  
    // If you want to download the image to your server:  
    // const imagePath = path.join(__dirname, '3.jpg');  
    // const response = await axios.get(publicImageUrl, { responseType: 'arraybuffer' });  
    // fs.writeFileSync(imagePath, response.data);  

    // --------------------------------------------------  
    // (c) Return a simple HTML page  
    // --------------------------------------------------  
    const html = `  
      <html>  
        <head><title>Supabase Node Example</title></head>  
        <body>  
          <h1>Bucket List</h1>  
          <p>${bucketsReport}</p>  

          <h2>Public Image</h2>  
          <!-- Displays the image from the public URL directly -->  
          <img src="${publicImageUrl}" alt="Image from Supabase" />  
        </body>  
      </html>  
    `;  
    res.setHeader('Content-Type', 'text/html');  
    res.send(html);  

  } catch (error) {  
    console.error(error);  
    res.status(500).send("Error listing buckets or fetching image.");  
  }  
});  

// 4) Start the server  
const PORT = process.env.PORT || 3000;  
app.listen(PORT, () => {  
  console.log(`Server running at http://localhost:${PORT}/`);  
});
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (i.e. Git)
provider = "postgresql"
</file>

<file path="app/actions/appointments.ts">
"use server"

import prisma from "@/app/lib/prisma"
import { z } from "zod"
import { v4 as uuidv4 } from 'uuid'
import { Logger } from "@/app/lib/logger"
const logger = Logger.getInstance();

const appointmentSchema = z.object({
  user_uid: z.string().uuid("Invalid user ID"),
  startdate: z.date(),
  enddate: z.date(),
  title: z.string().min(1, "Title is required"),
  description: z.string().optional(),
})

type AppointmentData = z.infer<typeof appointmentSchema>

const ORGANIZATION_ID = "d290f1ee-6c54-4b01-90e6-d701748f0851"

export async function addAppointment(data: AppointmentData) {
  try {
    const validatedData = appointmentSchema.parse(data)
    
    const newAppointment = await prisma.user_calendar_entries.create({
      data: {
        uid: uuidv4(),
        user_uid: validatedData.user_uid,
        startdate: validatedData.startdate,
        enddate: validatedData.enddate,
        title: validatedData.title,
        description: validatedData.description,
        active: true,
        date_created: new Date(),
        last_edit: new Date(),
        locked: false,
        orgid: ORGANIZATION_ID,
      },
    })

    if (!newAppointment) {
      throw new Error("Failed to create appointment")
    }

    return newAppointment
  } catch (error) {
    console.error("Error adding appointment:", error)
    if (error instanceof z.ZodError) {
      throw new Error(`Validation error: ${error.errors[0].message}`)
    }
    throw new Error(error instanceof Error ? error.message : "Failed to add appointment")
  }
}

export async function updateAppointment(id: string, data: AppointmentData) {
  try {
    const validatedData = appointmentSchema.parse(data)
    
    const updatedAppointment = await prisma.user_calendar_entries.update({
      where: { uid: id },
      data: {
        user_uid: validatedData.user_uid,
        startdate: validatedData.startdate,
        enddate: validatedData.enddate,
        title: validatedData.title,
        description: validatedData.description,
        last_edit: new Date(),
      },
    })

    if (!updatedAppointment) {
      throw new Error("Failed to update appointment")
    }

    return updatedAppointment
  } catch (error) {
    console.error("Error updating appointment:", error)
    if (error instanceof z.ZodError) {
      throw new Error(`Validation error: ${error.errors[0].message}`)
    }
    throw new Error(error instanceof Error ? error.message : "Failed to update appointment")
  }
}

export async function deleteAppointment(id: string) {
  await logger.info("appointments.ts", `Delete appointment called with ID: ${id}`);

  if (!id) {
    await logger.error("appointments.ts", `Appointment ID is required`);
    throw new Error("Appointment ID is required")
  }

  try {
    // Verify the appointment exists first
    await logger.info("appointments.ts", `Verifying appointment exists with ID: ${id}`);
    const appointment = await prisma.user_calendar_entries.findUnique({
      where: { uid: id }
    })

    await logger.debug("appointments.ts", `Found appointment: ${JSON.stringify(appointment)}`);

    if (!appointment) {
      throw new Error("Appointment not found")
    }

    // Then delete it
    const deletedAppointment = await prisma.user_calendar_entries.delete({
      where: { uid: id }
    })

    await logger.info("appointments.ts", `Successfully deleted appointment: ${JSON.stringify(deletedAppointment)}`);

    return deletedAppointment
  } catch (error) {
    await logger.error("appointments.ts", `Error deleting appointment: ${error instanceof Error ? error.message : 'Unknown error'}`);
    throw error
  }
}
</file>

<file path="app/actions/auth.ts">
import { auth, signIn, signOut } from "@/app/lib/auth"

// Server action to get session data
export async function getSessionData() {
  const session = await auth()
  if (!session) return null
  
  return {
    user: {
      name: session.user?.name,
      email: session.user?.email,
      orgId: session.user?.orgId,
      roles: session.user?.roles
    }
  }
}

export { auth, signIn, signOut }
</file>

<file path="app/api/appointments/route.ts">
'use server'

import { NextResponse } from "next/server"
import { z } from "zod"
import prisma from "@/app/lib/prisma"
import { v4 as uuidv4 } from 'uuid'

const appointmentSchema = z.object({
  user_uid: z.string(),
  startdate: z.string(),
  enddate: z.string(),
  title: z.string(),
  description: z.string().optional(),
})

export async function POST(request: Request) {
  try {
    const json = await request.json()
    const data = appointmentSchema.parse(json)

    const newAppointment = await prisma.user_calendar_entries.create({
      data: {
        uid: uuidv4(),
        user_uid: data.user_uid,
        startdate: new Date(data.startdate),
        enddate: new Date(data.enddate),
        title: data.title,
        description: data.description,
        active: true,
        date_created: new Date(),
        last_edit: new Date(),
        locked: false,
      },
    })

    return NextResponse.json(newAppointment)
  } catch (error: unknown) {
    console.error("Error creating appointment:", error)
    const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred'
    return NextResponse.json({ error: errorMessage }, { status: 500 })
  }
}
</file>

<file path="app/api/files/[uid]/db_read.ts">
import prisma from '@/app/lib/prisma';
import chalk from 'chalk';
import { fetchMedicalSchemes } from './other_fn';

// Handle GET requests for file data
export async function handleGetFileData(uid: string, orgId: string) {
  try {
    console.log(chalk.blue.bold(`🔍 API: Getting file data for UID: ${uid}`));

    // Fetch medical schemes
    const medicalSchemes = await fetchMedicalSchemes(orgId);
    console.log(chalk.cyan(`🏥 API: Fetched ${medicalSchemes.length} medical schemes`));

    // For new files or if no uid is provided, return a template
    if (!uid || uid === 'new') {
      console.log(chalk.yellow('📄 API: New file template requested'));
      return {
        data: {
          uid: '',
          file_number: '',
          account_number: '',
          patient: {
            id: '',
            title: '',
            name: '',
            initials: '',
            surname: '',
            dob: '',
            gender: '',
            cell_phone: '',
            additional_name: '',
            additional_cell: '',
            email: '',
            address: ''
          },
          medical_cover: {
            type: 'medical-aid',
            same_as_patient: false,
            member: {
              id: '',
              name: '',
              initials: '',
              surname: '',
              dob: '',
              cell: '',
              email: '',
              address: ''
            },
            medical_aid: {
              scheme_id: '',
              name: '',
              membership_number: '',
              dependent_code: ''
            }
          },
          notes: {
            file_notes: [],
            clinical_notes: []
          },
          medical_schemes: medicalSchemes // Added medical schemes to response
        },
        status: 200
      };
    }

    console.log(chalk.cyan(`🏢 API: Fetching file with UID: ${uid}`));

    // Find the file info record with expanded relationships
    const fileInfo = await prisma.file_info.findFirst({
      where: {
        uid: uid,
        active: true,
        orgid: orgId
      },
      include: {
        fileinfo_patient: {
          where: {
            active: true
          },
          include: {
            patient: {
              where: {
                active: true
              }
            },
            tab_notes: {
              where: {
                active: true
              },
              include: {
                tab_files: {
                  where: {
                    active: true
                  }
                }
              },
              orderBy: {
                time_stamp: 'desc'
              }
            }
          }
        },
        patient_medical_aid: {
          where: {
            active: true
          },
          include: {
            medical_scheme: true,
            patientmedicalaid_file_patient: {
              where: {
                active: true
              },
              include: {
                patient: true
              }
            }
          }
        },
        injury_on_duty: {
          where: {
            active: true
          }
        }
      },
    });

    if (!fileInfo) {
      console.log(chalk.yellow(`📭 API: File with UID ${uid} not found`));
      return { error: 'File not found', status: 404 };
    }

    // Get the first linked patient if it exists
    const filePatient = fileInfo.fileinfo_patient.length > 0 
      ? fileInfo.fileinfo_patient[0] 
      : null;
    const patient = filePatient?.patient || null;
    
    // Get medical aid info if it exists
    const medicalAid = fileInfo.patient_medical_aid.length > 0
      ? fileInfo.patient_medical_aid[0]
      : null;
    
    // Get injury on duty info if it exists
    const injuryOnDuty = fileInfo.injury_on_duty.length > 0
      ? fileInfo.injury_on_duty[0]
      : null;
    
    // Determine cover type based on available data
    let coverType = 'private'; // Default
    if (medicalAid) {
      coverType = 'medical-aid';
    } else if (injuryOnDuty) {
      coverType = 'injury-on-duty';
    }
    
    // Get medical aid member info if available
    let memberPatient = null;
    let isSameAsPatient = false;
    
    if (medicalAid && medicalAid.patientmedicalaid_file_patient.length > 0) {
      // Check if the linked patient is different from the main patient
      const linkRecord = medicalAid.patientmedicalaid_file_patient[0];
      if (linkRecord.patientid !== patient?.uid) {
        memberPatient = linkRecord.patient;
      } else {
        // If same as the main patient, set the flag
        isSameAsPatient = true;
      }
    }
    
    // Format member date of birth if exists
    let formattedMemberDob = '';
    if (memberPatient?.date_of_birth) {
      const dob = new Date(memberPatient.date_of_birth);
      formattedMemberDob = `${dob.getFullYear()}/${String(dob.getMonth() + 1).padStart(2, '0')}/${String(dob.getDate()).padStart(2, '0')}`;
    }

    // Process tab_notes and tab_files
    // Separate notes by type (file_notes or clinical_notes)
    const fileNotes = [];
    const clinicalNotes = [];
    
    // If filePatient exists, we can collect its tab_notes
    if (filePatient && filePatient.tab_notes) {
      for (const note of filePatient.tab_notes) {
        const noteObj = {
          uid: note.uid,
          time_stamp: note.time_stamp,
          notes: note.notes,
          tab_type: note.tab_type,
          files: note.tab_files.map(file => ({
            uid: file.uid,
            file_name: file.file_name,
            file_type: file.file_type,
            file_location: file.file_location
          }))
        };
        
        // Sort notes based on tab_type
        if (note.tab_type === 'file') {
          fileNotes.push(noteObj);
        } else if (note.tab_type === 'clinical') {
          clinicalNotes.push(noteObj);
        }
      }
    }

    console.log(chalk.cyan(`📝 API: Fetched ${fileNotes.length} file notes and ${clinicalNotes.length} clinical notes`));

    // Return the file data with expanded fields
    const fileData = {
      uid: fileInfo.uid,
      file_number: fileInfo.file_number || '',
      account_number: fileInfo.account_number || '',
      patient: {
        id: patient?.id || '',
        title: patient?.title || '',
        name: patient?.name || '',
        initials: patient?.initials || '',
        surname: patient?.surname || '',
        dob: patient?.date_of_birth ? `${new Date(patient.date_of_birth).getFullYear()}/${String(new Date(patient.date_of_birth).getMonth() + 1).padStart(2, '0')}/${String(new Date(patient.date_of_birth).getDate()).padStart(2, '0')}` : '',
        gender: patient?.gender || '',
        cell_phone: patient?.cell_phone || '',
        additional_name: patient?.additional_name || '',
        additional_cell: patient?.additional_cell || '',
        email: patient?.email || '',
        address: patient?.address || ''
      },
      medical_cover: {
        type: coverType,
        same_as_patient: isSameAsPatient,
        member: memberPatient ? {
          id: memberPatient.id || '',
          title: memberPatient.title || '',
          name: memberPatient.name || '',
          initials: memberPatient.initials || '',
          surname: memberPatient.surname || '',
          dob: formattedMemberDob,
          gender: memberPatient.gender || '',
          cell: memberPatient.cell_phone || '',
          email: memberPatient.email || '',
          address: memberPatient.address || ''
        } : {
          id: '',
          name: '',
          initials: '',
          surname: '',
          dob: '',
          cell: '',
          email: '',
          address: ''
        },
        medical_aid: medicalAid ? {
          scheme_id: medicalAid.medical_scheme_id || '',
          name: medicalAid.medical_scheme?.scheme_name || '',
          membership_number: medicalAid.membership_number || '',
          dependent_code: medicalAid.patient_dependant_code || ''
        } : {
          scheme_id: '',
          name: '',
          membership_number: '',
          dependent_code: ''
        },
        injury_on_duty: injuryOnDuty ? {
          company_name: injuryOnDuty.company_name || '',
          contact_person: injuryOnDuty.contact_person || '',
          contact_number: injuryOnDuty.contact_number || '',
          contact_email: injuryOnDuty.contact_email || ''
        } : {
          company_name: '',
          contact_person: '',
          contact_number: '',
          contact_email: ''
        }
      },
      notes: {
        file_notes: fileNotes,
        clinical_notes: clinicalNotes
      },
      medical_schemes: medicalSchemes // From existing code
    };

    console.log(chalk.green('✅ API: File data retrieved successfully'));
    console.log(JSON.stringify(fileData, null, 2));
    
    return { data: fileData, status: 200 };
  } catch (error) {
    console.error(chalk.red('💥 API: Error fetching file:'), error);
    return { error: 'Failed to fetch file', status: 500 };
  }
}
</file>

<file path="app/api/files/[uid]/other_fn.ts">
import prisma from '@/app/lib/prisma';
import chalk from 'chalk';
import { createClient } from '@supabase/supabase-js';
import { v4 as uuidv4 } from 'uuid';

// Initialize Supabase client
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

// Helper function to fetch medical schemes
export async function fetchMedicalSchemes(orgId: string) {
  try {
    // Fetch active medical schemes for the organization
    const schemes = await prisma.medical_scheme.findMany({
      where: {
        active: true,
        orgid: orgId
      },
      select: {
        uid: true,
        scheme_name: true
      },
      orderBy: {
        scheme_name: 'asc'
      }
    });
    
    return schemes;
  } catch (error) {
    console.error(chalk.red('💥 API: Error fetching medical schemes:'), error);
    return [];
  }
}

// Helper function to save a new note and its files
export async function saveNoteWithFiles(noteData) {
  try {
    console.log(chalk.blue.bold('📝 API: Saving new note'));
    
    // 1. Create the note record in tab_notes
    const newNote = await prisma.tab_notes.create({
      data: {
        uid: uuidv4(),
        orgid: noteData.orgId,
        fileinfo_patient_id: noteData.fileInfoPatientId,
        personid: noteData.patientId,
        time_stamp: new Date(noteData.timeStamp),
        notes: noteData.notes,
        tab_type: noteData.tabType, // 'file' or 'clinical'
        active: true,
        date_created: new Date(),
        last_edit: new Date()
      }
    });
    
    console.log(chalk.green(`✅ API: Note created with ID: ${newNote.uid}`));
    
    // 2. Upload files to Supabase and create records in tab_files
    const fileRecords = [];
    
    if (noteData.files && noteData.files.length > 0) {
      console.log(chalk.blue(`📁 API: Processing ${noteData.files.length} files`));
      
      for (const fileData of noteData.files) {
        // Generate a unique filename while preserving the extension
        const fileExtension = fileData.name.split('.').pop();
        const uniqueFileName = `${uuidv4()}.${fileExtension}`;
        const storageLocation = `${noteData.orgId}/note-docs/${uniqueFileName}`;
        
        // Upload to Supabase
        const { data, error } = await supabase.storage
          .from('note-docs')
          .upload(storageLocation, fileData.content);
        
        if (error) {
          console.error(chalk.red(`💥 API: Error uploading file: ${error.message}`));
          continue;
        }
        
        // Create record in tab_files
        const fileRecord = await prisma.tab_files.create({
          data: {
            uid: uuidv4(),
            orgid: noteData.orgId,
            tab_notes_id: newNote.uid,
            file_name: fileData.name,
            file_type: fileData.type,
            file_location: storageLocation,
            active: true,
            date_created: new Date(),
            last_edit: new Date()
          }
        });
        
        fileRecords.push({
          uid: fileRecord.uid,
          file_name: fileRecord.file_name,
          file_type: fileRecord.file_type,
          file_location: fileRecord.file_location
        });
        
        console.log(chalk.green(`✅ API: File uploaded and record created for ${fileData.name}`));
      }
    }
    
    // 3. Return the complete note data with file records
    const completeNote = {
      uid: newNote.uid,
      time_stamp: newNote.time_stamp,
      notes: newNote.notes,
      tab_type: newNote.tab_type,
      files: fileRecords
    };
    
    console.log(chalk.green('✅ API: Note saved successfully with all files'));
    return completeNote;
    
  } catch (error) {
    console.error(chalk.red('💥 API: Error saving note:'), error);
    throw error;
  }
}
</file>

<file path="app/api/settings/organization/[uid]/upload/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/app/lib/auth'
import { getSupabaseClient } from '@/app/lib/supabase'

export async function POST(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  const supabase = getSupabaseClient()
  if (!supabase) {
    return NextResponse.json({ error: 'Supabase client not initialized' }, { status: 500 })
  }
  
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized - No organization ID found' },
        { status: 401 }
      )
    }

    if (session.user.orgId !== params.uid) {
      return NextResponse.json(
        { error: 'Unauthorized - Organization mismatch' },
        { status: 403 }
      )
    }

    const formData = await request.formData()
    const file = formData.get('file') as File
    const type = formData.get('type') as string // 'logo' or 'consent'
    const consentNumber = formData.get('consentNumber') as string

    if (!file || !type) {
      return NextResponse.json(
        { error: 'Missing file or type' },
        { status: 400 }
      )
    }

    let path: string
    let contentType: string

    if (type === 'logo') {
      path = `${params.uid}/logo/${params.uid}-logo.jpg`
      contentType = 'image/jpeg'
    } else if (type === 'consent') {
      path = `${params.uid}/consent-forms/${params.uid}Consent${consentNumber}.txt`
      contentType = 'text/plain'
    } else {
      return NextResponse.json(
        { error: 'Invalid upload type' },
        { status: 400 }
      )
    }

    const { error: uploadError } = await supabase.storage
      .from('DigiFile_Public')
      .upload(path, file, {
        upsert: true,
        contentType
      })

    if (uploadError) {
      console.error('Supabase upload error:', uploadError)
      return NextResponse.json(
        { error: 'Failed to upload file' },
        { status: 500 }
      )
    }

    const { data: urlData } = supabase.storage
      .from('DigiFile_Public')
      .getPublicUrl(path)

    return NextResponse.json({ url: urlData.publicUrl })
  } catch (error) {
    console.error('Upload error:', error)
    return NextResponse.json(
      { error: 'Failed to process upload' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/api/settings/users/route.ts">
'use server'

import { NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

export async function GET() {
  try {
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: "Unauthorized" },
        { status: 401 }
      )
    }
    const isAdmin = session.user.roles.some(r => r.role.name.toLowerCase() === 'admin') || false;
    const isOrganizer = session.user.roles.some(r => r.role.name.toLowerCase() === 'organizer') || false;


    // Base query conditions
    const whereConditions: any = {
      AND: [
        { active: true },
        { orgid: session.user.orgId }
      ]
    }

    // If user is not admin/organizer, only show their own record
    if (!(isAdmin || isOrganizer)) {
      whereConditions.AND.push({ uid: session.user.id })
    }
    
    const users = await prisma.users.findMany({
      where: whereConditions,
      select: {
        uid: true,
        title: true,
        first_name: true,
        surname: true,
        email: true,
        username: true,
        cell_no: true
      }
    })

    return NextResponse.json(users)
  } catch (error) {
    console.error('Failed to fetch users:', error)
    return NextResponse.json(
      { error: "Failed to fetch users" },
      { status: 500 }
    )
  }
}
</file>

<file path="app/lib/logger/logger.service.ts">
/**
 * Example usage:
 * const logger = Logger.getInstance();
 * await logger.init();
 * await logger.info('myFile.ts', 'This is an info message');
 * 
 * Note: This logger only works in server-side components.
 * It will silently ignore any logging attempts from client components.
 */

import { promises as fs } from 'fs';
import path from 'path';
import { LogLevel, LoggerConfig, LogEntry } from './types';

export class Logger {
  private static instance: Logger;
  private config!: LoggerConfig;
  private initialized: boolean = false;
  private readonly LOG_DIR!: string;

  private constructor() {
    // Only initialize if we're on the server side
    if (typeof window === 'undefined') {
      this.config = {
        logLevels: {
          ERROR: true,
          WARNING: true,
          INFO: true,
          DEBUG: true
        },
        maxFileSize: 104857600, // 100MB
        maxLogFiles: 10,
        logDirectory: 'logs'
      };
      this.LOG_DIR = path.join(process.cwd(), this.config.logDirectory);
    }
  }

  public static getInstance(): Logger {
    if (!Logger.instance) {
      Logger.instance = new Logger();
    }
    return Logger.instance;
  }

  public async init(): Promise<void> {
    // Only initialize on server side
    if (typeof window !== 'undefined') return;
    
    if (this.initialized) return;
    
    await this.writeToFile('Logger initialized');
    this.initialized = true;
  }

  private formatLogEntry(level: LogLevel, fileName: string, message: string): string {
    const timestamp = new Date().toISOString().replace('T', ' ').replace('Z', '');
    return `[${timestamp}] (${level}) - ${fileName} - ${message}`;
  }
 
  private async writeToFile(message: string): Promise<void> {
    // Skip if we're on the client side
    if (typeof window !== 'undefined') return;

    try {
      await fs.mkdir(this.LOG_DIR, { recursive: true });
      const date = new Date().toISOString().split('T')[0];
      const logFile = path.join(this.LOG_DIR, `app-${date}.log`);
      await fs.appendFile(logFile, message + '\n');
    } catch (error) {
      console.error('Failed to write to log file:', error);
      throw error;
    }
  }

  private async writeLog(entry: LogEntry): Promise<void> {
    // Skip if we're on the client side
    if (typeof window !== 'undefined') return;

    const logMessage = this.formatLogEntry(entry.level, entry.fileName, entry.message);
    await this.writeToFile(logMessage);
  }

  public async log(level: LogLevel, fileName: string, message: string): Promise<void> {
    // Skip if we're on the client side
    if (typeof window !== 'undefined') return;
    
    if (!this.config?.logLevels[level]) return;

    await this.writeLog({
      timestamp: new Date().toISOString(),
      level,
      fileName,
      message
    });
  }

  public async error(fileName: string, message: string): Promise<void> {
    if (typeof window !== 'undefined') return;
    await this.log('ERROR', fileName, message);
  }

  public async warning(fileName: string, message: string): Promise<void> {
    if (typeof window !== 'undefined') return;
    await this.log('WARNING', fileName, message);
  }

  public async info(fileName: string, message: string): Promise<void> {
    if (typeof window !== 'undefined') return;
    await this.log('INFO', fileName, message);
  }

  public async debug(fileName: string, message: string): Promise<void> {
    if (typeof window !== 'undefined') return;
    await this.log('DEBUG', fileName, message);
  }
}
</file>

<file path="app/login/registration/practice-info-form.tsx">
'use client'

import { Input } from "@/app/components/ui/input"
import { Label } from "@/app/components/ui/label"
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/app/components/ui/select"
import { useEffect, useState } from 'react'

interface PracticeInfoFormProps {
  value: {
    practiceName: string;
    bhfNumber: string;
    hpcsaNumber?: string;
    practiceType?: string;
    vatNumber?: string;
  };
  onChange: (value: {
    practiceName: string;
    bhfNumber: string;
    hpcsaNumber?: string;
    practiceType?: string;
    vatNumber?: string;
  }) => void;
  errors?: {
    practiceName?: string[];
    bhfNumber?: string[];
  };
}

type PracticeType = {
  uuid: string
  codes: string | null
  name: string | null
}

export function PracticeInfoForm({ value, onChange, errors }: PracticeInfoFormProps) {
  const [practiceTypes, setPracticeTypes] = useState<PracticeType[]>([])

  useEffect(() => {
    const fetchPracticeTypes = async () => {
      try {
        const response = await fetch('/api/practice-types')
        const data = await response.json()
        if (response.ok) {
          setPracticeTypes(data)
        }
      } catch (error) {
        console.error('Error fetching practice types:', error)
      }
    }

    fetchPracticeTypes()
  }, [])

  const handleInputChange = (field: keyof typeof value) => (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    onChange({
      ...value,
      [field]: e.target.value,
    });
  };

  const handleSelectChange = (field: keyof typeof value) => (newValue: string) => {
    onChange({
      ...value,
      [field]: newValue,
    });
  };

  return (
    <div className="space-y-6 p-4">
      <div className="grid gap-2">
        <Label htmlFor="practiceName" className="after:content-['*'] after:ml-0.5 after:text-red-500">
          Practice Name
        </Label>
        <Input 
          id="practiceName" 
          placeholder="Enter practice name" 
          value={value.practiceName}
          onChange={handleInputChange('practiceName')}
          required
          aria-invalid={!!errors?.practiceName}
        />
        {errors?.practiceName && (
          <p className="text-sm text-red-500">{errors.practiceName.join(', ')}</p>
        )}
      </div>

      <div className="grid gap-2">
        <Label htmlFor="bhfNumber" className="after:content-['*'] after:ml-0.5 after:text-red-500">
          BHF Number
        </Label>
        <Input 
          id="bhfNumber" 
          placeholder="Enter BHF number" 
          value={value.bhfNumber}
          onChange={(e) => {
            const numbersOnly = e.target.value.replace(/[^0-9]/g, '');
            handleInputChange('bhfNumber')({ ...e, target: { ...e.target, value: numbersOnly } });
          }}
          required
          aria-invalid={!!errors?.bhfNumber}
        />
        {errors?.bhfNumber && (
          <p className="text-sm text-red-500">{errors.bhfNumber.join(', ')}</p>
        )}
      </div>

      <div className="grid gap-2">
        <Label htmlFor="hpcsaNumber">HPCSA Number</Label>
        <Input 
          id="hpcsaNumber" 
          placeholder="Enter HPCSA number"
          value={value.hpcsaNumber || ''}
          onChange={handleInputChange('hpcsaNumber')}
        />
      </div>

      <div className="grid gap-2">
        <Label htmlFor="practiceType">Practice Type</Label>
        <Select 
          value={value.practiceType}
          onValueChange={handleSelectChange('practiceType')}
        >
          <SelectTrigger id="practiceType">
            <SelectValue placeholder="Select practice type" />
          </SelectTrigger>
          <SelectContent>
            {practiceTypes.map((type) => (
              <SelectItem key={type.uuid} value={type.uuid}>
                {type.codes} - {type.name}
              </SelectItem>
            ))}
          </SelectContent>
        </Select>
      </div>

      <div className="grid gap-2">
        <Label htmlFor="vatNumber">VAT Number</Label>
        <Input 
          id="vatNumber" 
          placeholder="Enter VAT number"
          value={value.vatNumber || ''}
          onChange={handleInputChange('vatNumber')}
        />
      </div>
    </div>
  )
}
</file>

<file path="app/sites/layout.tsx">
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import { CollapsibleSidebar } from "@/app/components/ui/collapsible-sidebar";
import { Header } from "@/app/components/ui/header";

const inter = Inter({ subsets: ["latin"] });

export const metadata: Metadata = {
  title: "DigiFile",
  description: "Secure digital file management for healthcare",
};

export default function SitesLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <div className={`flex h-screen ${inter.className}`}>
      <CollapsibleSidebar />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Header />
        <main className="flex-1 overflow-y-auto">
          {children}
        </main>
      </div>
    </div>
  );
}
</file>

<file path="app/types/next-auth.d.ts">
import { DefaultSession } from "next-auth"

declare module "next-auth" {
  interface Session {
    user: {
      id: string;
      orgId: string;
      roles: {
        role: {
          uid: string;
          name: string;
        };
      }[];
    } & DefaultSession["user"]
  }
}

declare module "next-auth/jwt" {
  interface JWT {
    id: string;
    orgId: string;
    roles: {
      role: {
        uid: string;
        name: string;
      };
    }[];
  }
}
</file>

<file path="app/global-error.tsx">
"use client";

import Error from 'next/error';

export default function GlobalError() {
  return (
    <html>
      <body>
        <Error statusCode={500} />
      </body>
    </html>
  );
}
</file>

<file path="Helperfiles/ItemsToNote.md">
## Logo Management in GeneralSettings

### Implementation Details
- Location: 
  - Frontend: `app/sites/settings/GeneralSettings.tsx`
  - API: `app/api/settings/organization/[uid]/upload/route.ts`
- Storage Paths:
  - Logo: `/{OrgID}/logo/{OrgID}-logo.jpg`
  - Consent Forms: `/{OrgID}/consent-forms/{OrgID}Consent{1|2|3}.txt`
- Bucket: `DigiFile_Public`

### File Handling
1. **Logo Upload**
   - Handles image files
   - Stores as JPEG format
   - Updates preview immediately
   - Refreshes public URL after upload

2. **Consent Documents**
   - Handles text files
   - Stores in numbered format (consent1.txt, etc.)
   - Server-side validation
   - Separate view/upload functionality

### Button Types
- Submit button only for form submission
- View and Upload buttons set to type="button"
- Prevents unintended form submissions

### Security Considerations
1. **Server-side Upload**
   - Logo upload handled on server side
   - Uses service role key for Supabase operations
   - Validates organization ID against session
   - Prevents unauthorized access across organizations

2. **Error Handling**
   - Validates file presence
   - Checks organization permissions
   - Handles upload failures gracefully
   - Returns appropriate status codes

### Functionality
1. **Logo Display**
   - Fetches logo from Supabase using organization ID
   - Uses public URL for display
   - Falls back to placeholder if no logo exists

2. **Logo Upload**
   - Handles file selection and preview
   - Renames file to `{OrgID}-logo.jpg`
   - Uploads to Supabase on form submit
   - Uses upsert to replace existing logo

### Making Changes
To modify logo handling:
1. Update storage path in `fetchLogo` useEffect
2. Modify upload logic in `handleSubmit`
3. Adjust file type restrictions in input element
4. Update Supabase bucket name if needed

### Troubleshooting
1. **Image Loading Issues**
   - Use `unoptimized` prop on Next.js Image component
   - Add error handling to fall back to placeholder
   - Configure `remotePatterns` in next.config.js instead of `domains`

2. **Upload Issues**
   - Specify `contentType` in Supabase upload options
   - Refresh public URL after successful upload
   - Handle both upload and API response errors separately
   - Check network tab for detailed error responses

### Common Errors
1. **Empty Error Object**
   - Usually indicates a problem with the API response
   - Check network tab for actual response
   - Ensure proper error handling on both client and server
   - Verify organization ID is present in requests

### Related Files
- `app/sites/settings/GeneralSettings.tsx`
- `.env` (Supabase configuration)
- `next.config.js` (Image configuration)
- Supabase storage bucket configuration

### Storage Paths
- Logo: `/{OrgID}/logo/{OrgID}-logo.jpg`
- Consent Forms: `/{OrgID}/consent-forms/{OrgID}Consent{1|2|3}.txt`

### Consent Documents
1. **File Storage**
   - Stored as `{OrgID}Consent{1|2|3}.txt`
   - Server-side validation
   - Organization-specific paths
   - Text file format

2. **Viewing**
   - Modal display of content
   - Fetches content on demand
   - Server-side file retrieval
   - Error handling for missing files


### Session Management

1. **Session Structure**
   - Contains user identification and organization context
   - Includes role-based access control information
   - Available through auth() function server-side
   - Accessible via useSession() hook client-side

2. **Key Properties**
   - user.name: Full name from database
   - user.email: User's email address
   - user.orgId: Organization identifier
   - user.roles: Array of role objects
     - role.uid: Role unique identifier
     - role.name: Role name (e.g., "admin", "organizer")

3. **Role-Based Access**
   - Admin role: Full system access
   - Organizer role: Organization management
   - Regular users: Limited to own data
   - Role checks should use toLowerCase() for comparison

4. **Security Considerations**
   - Session includes orgId for multi-tenant separation
   - Roles determine UI element visibility
   - Server-side validation required despite client roles
   - Session timeout set to 30 minutes

5. **Usage Examples**
   ```typescript
   // Server-side
   const session = await auth()
   const orgId = session?.user?.orgId
   
   // Client-side
   const { data: session } = useSession()
   const isAdmin = session?.user?.roles?.some(r => 
     r.role.name.toLowerCase() === 'admin'
   )
   ```

6. **Implementation Files**
   - app/lib/auth.ts: Core authentication logic
   - app/hooks/use-session.ts: Client-side hook
   - app/types/next-auth.d.ts: Type definitions
   - app/lib/config.ts: Session configuration

### Settings Page Structure

1. **Components**
   - `settings/page.tsx`: Main settings layout with tabs
   - `settings/GeneralSettings.tsx`: Organization settings
   - `settings/UserSettings.tsx`: User management
   - `settings/DebitOrderSettings.tsx`: Debit order configuration

2. **Role-Based Access Control**
   - **Admin/Organizer Access**
     - Full access to all settings tabs
     - Can view and modify General Settings
     - Can manage User Settings and roles
     - Can access Debit Order Settings
   - **Regular User Access**
     - Limited to User Settings tab only
     - Can only edit their own user profile
     - Cannot view or modify organization settings
     - Cannot access debit order settings

3. **Tab Management**
   - Default tab selection based on user role
   - Admin/Organizer: defaults to "general"
   - Regular users: defaults to "users"
   - Conditional tab rendering prevents unauthorized access

4. **Implementation Details**
   ```typescript
   const hasAdminAccess = session?.user?.roles?.some(r => 
     r.role.name.toLowerCase() === 'admin' || 
     r.role.name.toLowerCase() === 'organizer'
   )
   ```
   - Used consistently across settings components
   - Controls both UI visibility and access
   - Applied at both tab and content levels

5. **Security Considerations**
   - Client-side role checks for UI rendering
   - Server-side validation required for all actions
   - Consistent role checking methodology
   - Protected API routes for sensitive operations

6. **User Settings Access Levels**
   - **Admin/Organizer**
     - Can view and edit all users
     - Can manage user roles
     - Full access to role management card
   - **Regular Users**
     - Can only view own profile
     - Can edit basic profile information
     - Cannot view or modify roles
     - Cannot access other users' data

7. **Best Practices**
   - Use `hasAdminAccess` helper consistently
   - Apply role checks at multiple levels
   - Maintain server-side validation
   - Keep UI clean and role-appropriate
   - Handle unauthorized access gracefully

8. **Related Components**
   - Tabs from shadcn/ui
   - Custom role-based buttons
   - Protected API routes
   - Session management integration

9. **Common Patterns**
   - Early role checks in components
   - Conditional rendering based on roles
   - Consistent access control helpers
   - Clear separation of admin/user functions

10. **Error Handling**
    - Graceful degradation for unauthorized access
    - Clear user feedback
    - Proper error boundaries
    - Role-appropriate error messages

### Calendar Access Control

1. **Role-Based Calendar Access**
   - **Admin/Organizer Access**
     - Can view all users' calendars
     - Full access to calendar management
     - Can add/edit appointments for any user
   - **Regular Users**
     - Can only view their own calendar
     - Limited to managing own appointments
     - Cannot access other users' calendars

2. **Implementation Details**
   ```typescript
   const hasAdminAccess = session?.user?.roles?.some(r => 
     r.role.name.toLowerCase() === 'admin' || 
     r.role.name.toLowerCase() === 'organizer'
   )
   ```
   - Used consistently in calendar components
   - Controls both UI visibility and data access
   - Applied at both client and server levels

3. **Security Implementation**
   - **Client-side**
     - Role checks for UI rendering
     - Filtered calendar view based on roles
     - Conditional rendering of admin features
   - **Server-side**
     - Session validation
     - Role-based data filtering
     - Organization-scoped queries
     - Protected API endpoints

4. **Data Access Patterns**
   - Admin/Organizer: All organization calendars
   - Regular users: Only personal calendar
   - Organization-scoped queries
   - Active user filtering

5. **Best Practices**
   - Consistent role checking methodology
   - Multi-level access control
   - Server-side validation for all actions
   - Clean UI separation based on roles
   - Proper error handling for unauthorized access

6. **Related Components**
   - Calendar page component
   - Calendar API routes
   - Appointment management
   - Session integration
   - Role-based UI elements

7. **Common Patterns**
   - Early role validation
   - Conditional data fetching
   - Consistent access helpers
   - Clear separation of admin/user views

8. **Error Handling**
   - Unauthorized access handling
   - Data fetch failures
   - Role-appropriate error messages
   - Graceful UI degradation
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts
</file>

<file path="middleware.ts">
import { NextResponse } from 'next/server'
import { auth } from '@/app/lib/auth'

export default auth((req) => {
  const isLoggedIn = !!req.auth
  const isOnSitesPage = req.nextUrl.pathname.startsWith('/sites')

  // If trying to access /sites/* without being logged in
  if (isOnSitesPage && !isLoggedIn) {
    return NextResponse.redirect(new URL('/login/signin', req.url))
  }

  // If logged in and trying to access login pages, redirect to /sites
  if (isLoggedIn && req.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/sites', req.url))
  }

  return NextResponse.next()
})

// Specify which routes to run the middleware on
export const config = {
  matcher: ['/sites/:path*', '/login/:path*']
}
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts" ],
  "exclude": ["node_modules"]
}
</file>

<file path="app/api/settings/users/[uid]/route.ts">
'use server'

import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

export async function PUT(
  request: NextRequest,
  context: { params: { uid: string } }
): Promise<NextResponse> {
  try {
    const { uid } = await Promise.resolve(context.params)
    
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const data = await request.json()
    console.log('Received data:', data)

    const updatedUser = await prisma.users.update({
      where: {
        uid: uid,
        orgid: session.user.orgId
      },
      data: {
        title: data.title,
        first_name: data.firstName,
        surname: data.lastName,
        username: data.username,
        email: data.email,
        cell_no: data.phone,
        last_edit: new Date()
      }
    })

    console.log('Updated user:', updatedUser)
    return NextResponse.json(updatedUser)
  } catch (error) {
    console.error('Failed to update user:', error)
    return NextResponse.json(
      { error: 'Failed to update user' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/components/ui/appointment/appointment-modal.tsx">
"use client"

import { useState, useTransition } from "react"
import { z } from "zod"
import { useForm } from "react-hook-form"
import { zodResolver } from "@hookform/resolvers/zod"
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/app/components/ui/dialog"
import { Button } from "@/app/components/ui/button"
import { Input } from "@/app/components/ui/input"
import { Label } from "@/app/components/ui/label"
import { Account, CalendarEvent } from "@/app/types/calendar"
import { addAppointment, deleteAppointment, updateAppointment } from "@/app/actions/appointments"
import { DateTimePicker } from "@/app/components/ui/date-time-picker"
import { useRouter } from "next/navigation"

interface AppointmentModalProps {
  accounts: Account[]
  onAppointmentAdded: () => void
  selectedEvent?: CalendarEvent
  onOpenChange?: (open: boolean) => void
  defaultOpen?: boolean
}

const appointmentSchema = z.object({
  user_uid: z.string().nonempty("Please select a user"),
  startdate: z.date(),
  enddate: z.date(),
  title: z.string().nonempty("Title is required"),
  description: z.string().optional(),
}).refine(data => data.enddate > data.startdate, {
  message: "End date must be after start date",
  path: ["enddate"],
})

type AppointmentFormData = z.infer<typeof appointmentSchema>

export function AppointmentModal({ 
  accounts, 
  onAppointmentAdded, 
  selectedEvent,
  onOpenChange,
  defaultOpen = false
}: AppointmentModalProps) {
  const [open, setOpen] = useState(defaultOpen)
  const [isPending, startTransition] = useTransition()
  const [error, setError] = useState<string | null>(null)

  const form = useForm<AppointmentFormData>({
    resolver: zodResolver(appointmentSchema),
    defaultValues: {
      user_uid: selectedEvent?.accountId || '',
      startdate: selectedEvent ? new Date(selectedEvent.start) : new Date(),
      enddate: selectedEvent ? new Date(selectedEvent.end) : new Date(),
      title: selectedEvent?.title || '',
      description: selectedEvent?.description || '',
    }
  })

  const router = useRouter()

  const handleOpenChange = (newOpen: boolean) => {
    setOpen(newOpen)
    onOpenChange?.(newOpen)
    if (!newOpen) {
      form.reset()
    }
  }

  const handleDelete = async () => {
    console.log("handleDelete called");
    debugger;
    if (!selectedEvent?.id) {
      setError("Cannot delete: Invalid appointment ID")
      return
    }

    startTransition(async () => {
      try {
        await deleteAppointment(selectedEvent.id)
        onAppointmentAdded()
        handleOpenChange(false)
        router.refresh()
      } catch (error) {
        setError(error instanceof Error ? error.message : "Failed to delete appointment")
      }
    })
  }

  const onSubmit = async (data: AppointmentFormData) => {
    setError(null)
    startTransition(async () => {
      try {
        if (selectedEvent?.id) {
          await updateAppointment(selectedEvent.id, data)
        } else {
          await addAppointment(data)
        }
        onAppointmentAdded()
        handleOpenChange(false)
        router.refresh()
      } catch (error) {
        setError(error instanceof Error ? error.message : "Failed to save appointment")
      }
    })
  }

  const handleDateChange = (field: 'startdate' | 'enddate') => (date: Date | null) => {
    form.setValue(field, date || new Date(), { 
      shouldValidate: true,
      shouldDirty: true 
    })
  }

  return (
    <Dialog open={open} onOpenChange={handleOpenChange}>
      <DialogTrigger asChild>
        <Button variant="outline">
          {selectedEvent ? "Edit Appointment" : "Add Appointment"}
        </Button>
      </DialogTrigger>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>
            {selectedEvent ? "Edit Appointment" : "Add New Appointment"}
          </DialogTitle>
        </DialogHeader>
        <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
          {error && <p className="text-red-500 text-sm">{error}</p>}
          {/* User Selection */}
          <div>
            <Label htmlFor="user_uid">User</Label>
            <select id="user_uid" {...form.register("user_uid")} className="w-full p-2 border rounded">
              <option value="">Select a user</option>
              {accounts.map(account => (
                <option key={account.AccountID} value={account.AccountID}>
                  {account.Name}
                </option>
              ))}
            </select>
            {form.formState.errors.user_uid && <p className="text-red-500 text-sm">{form.formState.errors.user_uid.message}</p>}
          </div>

          {/* Start DateTime */}
          <div>
            <Label htmlFor="startdate">Start Date and Time</Label>
            <DateTimePicker
              id="startdate"
              value={form.watch('startdate')}
              onChange={handleDateChange('startdate')}
            />
            {form.formState.errors.startdate && <p className="text-red-500 text-sm">{form.formState.errors.startdate.message}</p>}
          </div>

          {/* End DateTime */}
          <div>
            <Label htmlFor="enddate">End Date and Time</Label>
            <DateTimePicker
              id="enddate"
              value={form.watch('enddate')}
              onChange={handleDateChange('enddate')}
            />
            {form.formState.errors.enddate && <p className="text-red-500 text-sm">{form.formState.errors.enddate.message}</p>}
          </div>

          {/* Title */}
          <div>
            <Label htmlFor="title">Appointment Title</Label>
            <Input id="title" {...form.register("title")} />
            {form.formState.errors.title && <p className="text-red-500 text-sm">{form.formState.errors.title.message}</p>}
          </div>

          {/* Description */}
          <div>
            <Label htmlFor="description">Description</Label>
            <Input id="description" {...form.register("description")} />
            {form.formState.errors.description && <p className="text-red-500 text-sm">{form.formState.errors.description.message}</p>}
          </div>

          <div className="flex justify-end gap-2">
            {selectedEvent && (
              <Button
                type="button"
                variant="destructive"
                onClick={handleDelete}
                disabled={isPending}
              >
                Delete
              </Button>
            )}
            <Button
              type="button"
              variant="outline"
              onClick={() => handleOpenChange(false)}
            >
              Cancel
            </Button>
            <Button 
              type="submit" 
              disabled={isPending}
            >
              {isPending ? "Saving..." : (selectedEvent ? "Update" : "Add")}
            </Button>
          </div>
        </form>
      </DialogContent>
    </Dialog>
  )
}
</file>

<file path="app/login/signin/page.tsx">
'use client'

import { useState } from 'react'
import Link from 'next/link'
import { useRouter } from 'next/navigation'
import { signIn } from 'next-auth/react'
import { Button } from "@/app/components/ui/button"
import { Input } from "@/app/components/ui/input"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/app/components/ui/dialog"
import { toast } from "sonner"

export default function SigninPage() {
  const router = useRouter()
  const [showForgotPassword, setShowForgotPassword] = useState(false)
  const [isLoading, setIsLoading] = useState(false)
  const [formData, setFormData] = useState({
    bfhNumber: '',
    username: '',
    password: ''
  })

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)

    try {
      //debugger;
      const result = await signIn('credentials', {
        bfhNumber: formData.bfhNumber,
        username: formData.username,
        password: formData.password,
        redirect: false,
      })

      if (result?.error) {
        toast.error('Invalid username, BFH number, or password')
      } else {
        router.push('/sites')
        router.refresh()
      }
    } catch (error) {
      console.error('Sign in exception:', error)
      toast.error('An error occurred during sign in')
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <div className="container mx-auto max-w-md mt-20 p-6">
      {/* Logo */}
      <Link href="/" className="block mb-12 text-3xl font-bold">
        <span className="text-blue-600">Digi</span>File
      </Link>

      {/* Sign In Form */}
      <form onSubmit={handleSubmit} className="space-y-6">
        <Input
          placeholder="BFH Number"
          value={formData.bfhNumber}
          onChange={(e) => setFormData(prev => ({ ...prev, bfhNumber: e.target.value }))}
          disabled={isLoading}
          required
        />
        
        <Input
          placeholder="Username"
          value={formData.username}
          onChange={(e) => setFormData(prev => ({ ...prev, username: e.target.value }))}
          disabled={isLoading}
          required
        />
        
        <Input
          type="password"
          placeholder="Password"
          value={formData.password}
          onChange={(e) => setFormData(prev => ({ ...prev, password: e.target.value }))}
          disabled={isLoading}
          required
        />

        <Button 
          type="submit" 
          className="w-full"
          disabled={isLoading}
        >
          {isLoading ? 'Signing in...' : 'Login'}
        </Button>
      </form>

      {/* Links */}
      <div className="mt-6 flex justify-between text-sm">
        <Link 
          href="/login/registration" 
          className="text-green-600 hover:underline"
        >
          Register
        </Link>
        <button
          onClick={() => setShowForgotPassword(true)}
          className="text-purple-600 hover:underline"
        >
          Forgot Password
        </button>
      </div>

      {/* Forgot Password Modal */}
      <Dialog open={showForgotPassword} onOpenChange={setShowForgotPassword}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Reset Password</DialogTitle>
          </DialogHeader>
          {/* TODO: Implement forgot password form */}
        </DialogContent>
      </Dialog>
    </div>
  )
}
</file>

<file path="app/types/calendar.ts">
export interface CalendarEntry {
  uid: string
  startdate: string
  enddate: string
  title: string
  length: string
  description: string
}

export interface Account {
  AccountID: string
  Name: string
  "Calendar-Entries": CalendarEntry[]
  color: string
}

export type ViewType = "day" | "week" | "month" 

export interface CalendarEvent {
  id: string
  title: string
  start: Date
  end: Date
  accountId: string
  accountName: string
  color: string
  description?: string
}
</file>

<file path="app/utils/calendar.ts">
import { Account, CalendarEvent } from "@/app/types/calendar"
import { Logger } from "@/app/lib/logger"

const logger = Logger.getInstance();
logger.init().catch(console.error);

export async function transformEntriesToEvents(accounts: Account[]): Promise<CalendarEvent[]> {
  await logger.info("calendar.ts", `Transforming entries for ${accounts.length} accounts`);
  
  try {
    const events = [];
    for (let i = 0; i < accounts.length; i++) {
      const account = accounts[i];
      
      await logger.debug("calendar.ts", 
        `Processing account ${account.Name} (${account.AccountID})`
      );

      for (const entry of account["Calendar-Entries"]) {
        const start = new Date(entry.startdate);
        const end = new Date(entry.enddate);
        /// new Date(start.getTime() + parseInt(entry.Length) * 60000);

        await logger.debug(
          "calendar.ts",
          `Creating event for entry UID: ${entry.uid}`
        );

        events.push({
          id: entry.uid,
          title: entry.title,
          start,
          end,
          accountId: account.AccountID,
          accountName: account.Name,
          color: account.color,
          description: entry.description
        });
      }
    }
    
    return events;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    await logger.error("calendar.ts", 
      `Error transforming calendar entries: ${errorMessage}`
    );
    throw error;
  }
}
</file>

<file path="tailwind.config.ts">
import type { Config } from "tailwindcss";

export default {
    darkMode: ["class"],
    content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  safelist: [
    'bg-blue-500',
    'bg-green-500', 
    'bg-purple-500',
    'bg-orange-500',
    'bg-pink-500',
    'bg-cyan-500',
    'bg-yellow-500',
    'bg-red-500',
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate"), require('@tailwindcss/typography')],
} satisfies Config;
</file>

<file path="app/api/files/[uid]/route.ts">
import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/app/lib/auth';
import chalk from 'chalk';
import { handleGetFileData } from './db_read';
import { handleUpdateFile, handleCreateFile } from './db_write';

// GET a single file by uid
export async function GET(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  try {
    console.log(chalk.blue.bold(`🔍 API: /api/files/${params.uid} GET called`));
    const session = await auth();
    if (!session?.user?.orgId) {
      console.log(chalk.red('❌ API: No organization ID found in session'));
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const result = await handleGetFileData(params.uid, session.user.orgId);
    
    if (result.error) {
      return NextResponse.json({ error: result.error }, { status: result.status });
    }
    
    return NextResponse.json(result.data);
  } catch (error) {
    console.error(chalk.red('💥 API: Error in GET route:'), error);
    return NextResponse.json({ error: 'Failed to fetch file' }, { status: 500 });
  }
}

// PUT endpoint for updating an existing file
export async function PUT(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  try {
    console.log(chalk.blue.bold(`🔍 API: /api/files/${params.uid} PUT called`));
    const session = await auth();
    if (!session?.user?.orgId) {
      console.log(chalk.red('❌ API: No organization ID found in session'));
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const data = await request.json();
    
    const result = await handleUpdateFile(params.uid, data, session.user.orgId);
    
    if (result.error) {
      return NextResponse.json({ error: result.error }, { status: result.status });
    }
    
    return NextResponse.json(result.data);
  } catch (error) {
    console.error(chalk.red('💥 API: Error in PUT route:'), error);
    return NextResponse.json({ error: 'Failed to update file' }, { status: 500 });
  }
}

// POST endpoint for creating a new file
export async function POST(
  request: NextRequest,
  { params }: { params: { uid: string } }
) {
  try {
    console.log(chalk.blue.bold(`🔍 API: /api/files/new POST called`));
    const session = await auth();
    if (!session?.user?.orgId) {
      console.log(chalk.red('❌ API: No organization ID found in session'));
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    const data = await request.json();
    
    const result = await handleCreateFile(data, session.user.orgId);
    
    if (result.error) {
      return NextResponse.json({ error: result.error }, { status: result.status });
    }
    
    return NextResponse.json(result.data);
  } catch (error) {
    console.error(chalk.red('💥 API: Error in POST route:'), error);
    return NextResponse.json({ error: 'Failed to create new file' }, { status: 500 });
  }
}
</file>

<file path="app/api/settings/users/[uid]/roles/route.ts">
import { NextRequest, NextResponse } from 'next/server'
import prisma from '@/app/lib/prisma'
import { auth } from '@/app/lib/auth'

// Get roles for a specific user
export async function GET(
  request: NextRequest,
  context: { params: { uid: string } }
) {
  try {
    const { uid } = await Promise.resolve(context.params)
    
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    } 

    // Fetch user roles using $queryRaw
    const userRoles = await prisma.$queryRaw`
        SELECT 
        ur.uid,
        r.uid AS role_uid,
        r.role_name,
        r.description
      FROM 
        user_roles AS ur
      JOIN 
        roles AS r ON ur.roleid = r.uid
      WHERE 
        ur.userid = ${uid}::uuid AND
        ur.orgid = ${session.user.orgId}::uuid AND
        ur.active = true
    ` || []  // Default to empty array if null

    // Transform the result to match the expected shape, handling null case
    const roles = Array.isArray(userRoles) 
      ? userRoles.map((ur: any) => ({
          uid: ur.role_uid || '',
          role_name: ur.role_name || '',
          description: ur.description || null
        }))
      : []

    return NextResponse.json(roles)
  } catch (error) {
    if (error) {
        console.error('Failed to fetch user roles:', error)
      } else {
        console.error('Failed to fetch user roles: Unknown error')
      }
    return NextResponse.json(
      { error: 'Failed to fetch user roles' },
      { status: 500 }
    )
  }
}

// Add or remove roles for a user
export async function PUT(
  request: NextRequest,
  context: { params: { uid: string } }
) {

    console.log("Hello World");
  try {
    const { uid } = await Promise.resolve(context.params)
    
    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const { roleIds, action } = await request.json()

    if (!Array.isArray(roleIds) || !['add', 'remove'].includes(action)) {
      return NextResponse.json(
        { error: 'Invalid request body' },
        { status: 400 }
      )
    }

    console.log("Jan, what is this?")
    if (action === 'add') {

        console.log("Adding Role");

      // Check for existing role (active or inactive)
      const existingRole = await prisma.user_roles.findFirst({
        where: {
          userid: uid, 
          roleid: roleIds[0],
          orgid: session.user.orgId,
        }
      })

      console.log("Existing Role:", existingRole);

      if (existingRole) {
        // Update existing role to active

        console.log("Updating Existing Role");
        await prisma.user_roles.update({
          where: {
            uid: existingRole.uid
          },
          data: {
            active: true,
            last_edit: new Date()
          }
        })

        console.log("Existing Role Updated");

      } else {

        console.log("Creating New Role");
        // Create new user role record
        await prisma.user_roles.create({
          data: {
            uid: crypto.randomUUID(),
            userid: uid,
            roleid: roleIds[0],
            orgid: session.user.orgId,
            active: true,
            date_created: new Date(),
            last_edit: new Date(),
            locked: false
          }
        })

        console.log("New Role Created");
      }
    } else {

        console.log("Removing Role");
        
      // Set role to inactive
      await prisma.user_roles.updateMany({
        where: {
          userid: uid,
          roleid: { in: roleIds },
          orgid: session.user.orgId,
          active: true
        },
        data: {
          active: false,
          last_edit: new Date()
        }
      })

      console.log("Role Removed");
    }

    console.log("Jan, Add and Remove worked?")

    // Fetch updated roles with role details
    const updatedUserRoles = await prisma.$queryRaw`
    SELECT 
    ur.uid,
    r.uid AS role_uid,
    r.role_name,
    r.description
  FROM 
    user_roles AS ur
  JOIN 
    roles AS r ON ur.roleid = r.uid
  WHERE 
    ur.userid = ${uid}::uuid AND
    ur.orgid = ${session.user.orgId}::uuid AND
    ur.active = true
` || []

    console.log("Jan, Updated User Roles:", updatedUserRoles);

    // Transform the result to return just the role details
    const roles = Array.isArray(updatedUserRoles) 
      ? updatedUserRoles.map((ur: any) => ({
          uid: ur.role_uid || '',
          role_name: ur.role_name || '',
          description: ur.description || null
        }))
      : []

    return NextResponse.json(roles)

  } catch (error) {
    console.error('Failed to update user roles:', error)
    return NextResponse.json(
      { error: 'Failed to update user roles' },
      { status: 500 }
    )
  }
}
</file>

<file path="app/lib/auth.ts">
import NextAuth from "next-auth"
import { PrismaAdapter } from "@auth/prisma-adapter"
import CredentialsProvider from "next-auth/providers/credentials"
import prisma from "@/app/lib/prisma"

// Only keep ExtendedUser interface
interface ExtendedUser {
  orgid: string;
  uid: string;
}

export const {
  handlers: { GET, POST },
  auth,
  signIn,
  signOut,
} = NextAuth({
  adapter: PrismaAdapter(prisma),
  session: { strategy: "jwt" },
  pages: {
    signIn: '/login',
  },
  callbacks: {
    async jwt({ token, user: dbUser }) {
      const user = dbUser as ExtendedUser | null
      if (user) {
        token.id = user.uid
        token.orgId = user.orgid
        const userRoles = await prisma.user_roles.findMany({
          where: {
            userid: user.uid,
            active: true,
            orgid: user.orgid
          }
        })

        const rolesWithDetails = await Promise.all(
          userRoles.map(async (userRole) => {
            const roleDetails = await prisma.roles.findFirst({
              where: {
                uid: userRole.roleid!,
                active: true
              }
            })
            return {
              role: {
                uid: roleDetails?.uid || '',
                name: roleDetails?.role_name || ''
              }
            }
          })
        )
        token.roles = rolesWithDetails
      }
      return token
    },
    async session({ session, token }) {
      return {
        ...session,
        user: {
          ...session.user,
          id: token.id as string,
          orgId: token.orgId as string,
          roles: token.roles
        }
      }
    }
  },
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        bfhNumber: { label: "BFH Number", type: "text" },
        username: { label: "Username", type: "text" },
        password: { label: "Password", type: "password" }
      },
      async authorize(credentials) {
        
        if (!credentials?.bfhNumber || !credentials?.username || !credentials?.password) {
          return null
        }


        try {
          const org = await prisma.organization_info.findFirst({
            where: {
              bhf_number: credentials.bfhNumber,
              active: true
            }
          })


          if (!org) return null

          const user = await prisma.users.findFirst({
            where: {
              username: credentials.username,
              orgid: org.uid,
              secret_key: credentials.password,
              active: true
            }
          })

          if (!user) return null

          return {
            uid: user.uid,
            name: `${user.first_name} ${user.surname}`,
            email: user.email,
            orgid: user.orgid
          }
        } catch (error) {
          console.error('Error during authorization:', error)
          return null
        }
      }
    })
  ]
})
</file>

<file path="app/sites/settings/GeneralSettings.tsx">
'use client'

import { useState, useEffect, FormEvent } from "react"
import { Upload } from "lucide-react"
import Image from "next/image"
import { Button } from "@/app/components/ui/button"
import { Card } from "@/app/components/ui/card"
import { Input } from "@/app/components/ui/input"
import { ScrollArea } from "@/app/components/ui/scroll-area"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/app/components/ui/select"
import { ConsentModal } from "@/app/components/ui/consent-modal"
import { toast } from "sonner"
import { createClient } from '@supabase/supabase-js'

type OrganizationInfo = {
  uid: string
  practice_name: string | null
  practice_type: string | null
  bhf_number: string | null
  hpcsa: string | null
  vat_no: string | null
  address: string | null
  postal: string | null
  practice_telephone: string | null
  accounts_telephone: string | null
  cell: string | null
  fax: string | null
  email: string | null
}

type PracticeType = {
  uuid: string
  codes: string | null
  name: string | null
}

// Add Supabase client initialization
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
)

export function GeneralSettings() {
  const [orgInfo, setOrgInfo] = useState<OrganizationInfo | null>(null)
  const [isLoading, setIsLoading] = useState(true)
  const [logoUrl, setLogoUrl] = useState("/placeholder.svg?height=200&width=200")
  const [isModalOpen, setIsModalOpen] = useState(false)
  const [selectedConsent, setSelectedConsent] = useState<number | null>(null)
  const [error, setError] = useState<string | null>(null)
  const [practiceTypes, setPracticeTypes] = useState<PracticeType[]>([])
  const [logoFile, setLogoFile] = useState<File | null>(null)

  // Fetch organization info
  useEffect(() => {
    const fetchOrgInfo = async () => {
      try {
        setError(null)
        const response = await fetch('/api/settings/organization')
        const data = await response.json()
        
        if (!response.ok) {
          throw new Error(data.error || 'Failed to fetch organization info')
        }
        
        setOrgInfo(data)
      } catch (error) {
        console.error('Error fetching organization info:', error)
        setError(error instanceof Error ? error.message : 'An error occurred')
      } finally {
        setIsLoading(false)
      }
    }

    fetchOrgInfo()
  }, [])

  useEffect(() => {
    const fetchPracticeTypes = async () => {
      try {
        const response = await fetch('/api/practice-types')
        const data = await response.json()
        if (response.ok) {
          setPracticeTypes(data)
        }
      } catch (error) {
        console.error('Error fetching practice types:', error)
      }
    }

    fetchPracticeTypes()
  }, [])

  // Fetch logo on component mount
  useEffect(() => {
    const fetchLogo = async () => {
      if (!orgInfo?.uid) return
      
      const { data } = supabase.storage
        .from('DigiFile_Public')
        .getPublicUrl(`${orgInfo.uid}/logo/${orgInfo.uid}-logo.jpg`)

      if (data?.publicUrl) {
        setLogoUrl(data.publicUrl)
      }
    }

    fetchLogo()
  }, [orgInfo?.uid])

  const handleSubmit = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (!orgInfo?.uid) return

    try {
      // Handle logo upload if new file was selected
      if (logoFile) {
        const formData = new FormData()
        formData.append('file', logoFile)

        const uploadResponse = await fetch(`/api/settings/organization/${orgInfo.uid}/logo`, {
          method: 'PUT',
          body: formData
        })

        if (!uploadResponse.ok) {
          const error = await uploadResponse.json()
          throw new Error(error.error || 'Failed to upload logo')
        }

        const { url: newLogoUrl } = await uploadResponse.json()
        setLogoUrl(newLogoUrl)
      }

      // Rest of the organization update logic
      const response = await fetch(`/api/settings/organization/${orgInfo.uid}`, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          practice_name: orgInfo.practice_name,
          practice_type: orgInfo.practice_type,
          bhf_no: orgInfo.bhf_number,
          vat_no: orgInfo.vat_no,
          address_physical: orgInfo.address,
          postal: orgInfo.postal,
          practice: orgInfo.practice_telephone,
          accounts: orgInfo.accounts_telephone,
          cell_no: orgInfo.cell,
          fax: orgInfo.fax,
          email: orgInfo.email
        }),
      })

      const responseData = await response.json()
      
      if (!response.ok) {
        throw new Error(responseData.error || 'Failed to update organization info')
      }
      
      setOrgInfo(responseData)
      toast.success('Organization information updated successfully')
    } catch (error) {
      console.error('Error updating organization info:', error)
      toast.error(error instanceof Error ? error.message : 'An error occurred while updating')
    }
  }

  const handleInputChange = (field: keyof OrganizationInfo, value: string) => {
    if (!orgInfo) return
    setOrgInfo(prev => ({
      ...prev!,
      [field]: value
    }))
  }

  const handleFileUpload = async (file: File, type: 'logo' | 'consent', consentNumber?: number) => {
    if (!orgInfo?.uid) return

    const formData = new FormData()
    formData.append('file', file)
    formData.append('type', type)
    if (type === 'consent' && consentNumber) {
      formData.append('consentNumber', consentNumber.toString())
    }

    try {
      const uploadResponse = await fetch(`/api/settings/organization/${orgInfo.uid}/upload`, {
        method: 'PUT',
        body: formData
      })

      if (!uploadResponse.ok) {
        const error = await uploadResponse.json()
        throw new Error(error.error || 'Failed to upload file')
      }

      const { url: newUrl } = await uploadResponse.json()
      
      if (type === 'logo') {
        setLogoUrl(newUrl)
      }
      
      toast.success(`${type === 'logo' ? 'Logo' : 'Consent document'} uploaded successfully`)
    } catch (error) {
      console.error('Upload error:', error)
      toast.error(error instanceof Error ? error.message : 'Failed to upload file')
    }
  }

  const handleImageUpload = (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0]
    if (file) {
      setLogoFile(file)
      const url = URL.createObjectURL(file)
      setLogoUrl(url)
      handleFileUpload(file, 'logo')
    }
  }

  const handleConsentFileUpload = (event: React.ChangeEvent<HTMLInputElement>, consentNumber: number) => {
    const file = event.target.files?.[0]
    if (file) {
      handleFileUpload(file, 'consent', consentNumber)
    }
  }

  const openModal = (consentNumber: number) => {
    setSelectedConsent(consentNumber)
    setIsModalOpen(true)
  }

  if (isLoading) {
    return (
      <div className="flex h-full items-center justify-center">
        <div className="text-gray-500">Loading organization information...</div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex h-full items-center justify-center">
        <div className="text-red-500">Error: {error}</div>
      </div>
    )
  }

  if (!orgInfo) {
    return (
      <div className="flex h-full items-center justify-center">
        <div className="text-gray-500">No organization information found.</div>
      </div>
    )
  }

  return (
    <div className="h-full bg-gray-50">
      <div className="h-full overflow-y-auto">
        <form onSubmit={handleSubmit} className="space-y-4 p-4">
          {/* Organization Info Card */}
          <Card className="p-6">
            <div className="grid grid-cols-2 gap-6">
              <div className="space-y-4">
                {/* Logo section */}
                <div className="space-y-4">
                  <div className="aspect-square w-full max-w-[200px] overflow-hidden rounded-lg border">
                    <Image
                      src={logoUrl}
                      alt="Company logo"
                      width={200}
                      height={200}
                      className="h-full w-full object-cover"
                      unoptimized
                      onError={() => {
                        setLogoUrl("/placeholder.svg?height=200&width=200")
                      }}
                    />
                  </div>
                  <div>
                    <input
                      type="file"
                      accept="image/*"
                      id="logo-upload"
                      className="sr-only"
                      onChange={handleImageUpload}
                    />
                    <label htmlFor="logo-upload">
                      <Button variant="outline" className="w-full" asChild>
                        <span>
                          <Upload className="mr-2 h-4 w-4" />
                          Upload Logo
                        </span>
                      </Button>
                    </label>
                  </div>
                </div>

                <div className="pt-4">
                  <Select
                    value={orgInfo?.practice_type || ''}
                    onValueChange={(value) => handleInputChange('practice_type', value)}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Practice Type" />
                    </SelectTrigger>
                    <SelectContent>
                      {practiceTypes.map((type) => (
                        <SelectItem key={type.uuid} value={type.uuid}>
                          {type.codes} - {type.name}
                        </SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>
              </div>

              <div className="space-y-4">
                <div>
                  <label htmlFor="practice-name" className="block text-sm font-medium text-gray-700">
                    Practice Name
                  </label>
                  <Input
                    id="practice-name"
                    value={orgInfo?.practice_name || ''}
                    onChange={(e) => handleInputChange('practice_name', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="bhf-number" className="block text-sm font-medium text-gray-700">
                    BHF Number
                  </label>
                  <Input
                    id="bhf-number"
                    value={orgInfo?.bhf_number || ''}
                    onChange={(e) => handleInputChange('bhf_number', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="hpcsa" className="block text-sm font-medium text-gray-700">
                    HPCSA Number
                  </label>
                  <Input
                    id="hpcsa"
                    value={orgInfo?.hpcsa || ''}
                    onChange={(e) => handleInputChange('hpcsa', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div className="pt-4">
                  <label htmlFor="vat-number" className="block text-sm font-medium text-gray-700">
                    VAT No.
                  </label>
                  <Input
                    id="vat-number"
                    value={orgInfo?.vat_no || ''}
                    onChange={(e) => handleInputChange('vat_no', e.target.value)}
                    className="mt-1"
                  />
                </div>
              </div>
            </div>
          </Card>

          {/* Contact Details Card */}
          <Card className="p-6">
            <div className="grid grid-cols-2 gap-6">
              <div className="space-y-4">
                <div>
                  <label htmlFor="address" className="block text-sm font-medium text-gray-700">
                    Address Physical
                  </label>
                  <Input
                    id="address"
                    value={orgInfo?.address || ''}
                    onChange={(e) => handleInputChange('address', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="practice_telephone " className="block text-sm font-medium text-gray-700">
                    Practice
                  </label>
                  <Input
                    id="practice_telephone"
                    value={orgInfo?.practice_telephone  || ''}
                    onChange={(e) => handleInputChange('practice_telephone', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="cell" className="block text-sm font-medium text-gray-700">
                    Cell Number
                  </label>
                  <Input
                    id="cell"
                    value={orgInfo?.cell || ''}
                    onChange={(e) => handleInputChange('cell', e.target.value)}
                    type="tel"
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="fax" className="block text-sm font-medium text-gray-700">
                    Fax
                  </label>
                  <Input
                    id="fax"
                    value={orgInfo?.fax || ''}
                    onChange={(e) => handleInputChange('fax', e.target.value)}
                    className="mt-1"
                  />
                </div>
              </div>

              <div className="space-y-4">
                <div>
                  <label htmlFor="postal" className="block text-sm font-medium text-gray-700">
                    Postal Address
                  </label>
                  <Input
                    id="postal"
                    value={orgInfo?.postal || ''}
                    onChange={(e) => handleInputChange('postal', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="accounts_telephone" className="block text-sm font-medium text-gray-700">
                    Accounts
                  </label>
                  <Input
                    id="accounts_telephone"
                    value={orgInfo?.accounts_telephone || ''}
                    onChange={(e) => handleInputChange('accounts_telephone', e.target.value)}
                    className="mt-1"
                  />
                </div>
                <div>
                  <label htmlFor="email" className="block text-sm font-medium text-gray-700">
                    Email
                  </label>
                  <Input
                    id="email"
                    value={orgInfo?.email || ''}
                    onChange={(e) => handleInputChange('email', e.target.value)}
                    type="email"
                    className="mt-1"
                  />
                </div>
              </div>
            </div>
          </Card>

          {/* Consent Documents Card */}
          <Card className="p-6">
            <div className="space-y-4">
              <h3 className="text-lg font-medium">Consent Documents</h3>
              {[1, 2, 3].map((consentNumber) => (
                <div key={consentNumber} className="flex items-center justify-between">
                  <span className="text-sm font-medium text-gray-700">
                    Consent {consentNumber}
                  </span>
                  <div className="flex gap-2">
                    <Button
                      type="button"
                      variant="outline"
                      onClick={() => openModal(consentNumber)}
                    >
                      View
                    </Button>
                    <div>
                      <input
                        type="file"
                        accept=".txt"
                        id={`consent-${consentNumber}-upload`}
                        className="sr-only"
                        onChange={(e) => handleConsentFileUpload(e, consentNumber)}
                      />
                      <label htmlFor={`consent-${consentNumber}-upload`}>
                        <Button variant="outline" type="button" asChild>
                          <span>
                            <Upload className="mr-2 h-4 w-4" />
                            Upload
                          </span>
                        </Button>
                      </label>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          </Card>

        {/* Save Changes Button */}
        <div className="flex justify-end">
          <Button type="submit">
            Save Changes
          </Button>
        </div>
        </form>
      </div>

      {selectedConsent && (
        <ConsentModal
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          consentNumber={selectedConsent}
          orgId={orgInfo.uid}
        />
      )}
    </div>
  )
}
</file>

<file path="app/sites/settings/UserSettings.tsx">
'use client'

import { useState, useEffect, FormEvent } from "react"
import { useSession } from "next-auth/react"
import { Card } from "@/app/components/ui/card"
import { Button } from "@/app/components/ui/button"
import { Input } from "@/app/components/ui/input"
import { ScrollArea } from "@/app/components/ui/scroll-area"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/app/components/ui/select"
import { config } from "@/app/lib/config"
import { toast } from 'sonner'

type User = {
  uid: string
  title: string | null
  first_name: string | null
  surname: string | null
  email: string | null
  username: string | null
  cell_no: string | null
}

interface UpdateUserPayload {
  title: string
  firstName: string
  lastName: string
  username: string
  email: string
  phone: string
}

type Role = {
  uid: string
  role_name: string
  description: string | null
}

export function UserSettings() {
  const { data: session, status } = useSession()
  const [users, setUsers] = useState<User[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [selectedUser, setSelectedUser] = useState<User | null>(null)
  const [formData, setFormData] = useState<UpdateUserPayload>({
    title: '',
    firstName: '',
    lastName: '',
    username: '',
    email: '',
    phone: ''
  })
  const [availableRoles, setAvailableRoles] = useState<Role[]>([])
  const [userRoles, setUserRoles] = useState<Role[]>([])

  const isAdmin = session?.user?.roles?.some(r => 
    r.role.name.toLowerCase() === 'admin'
  )
  const isOrganizer = session?.user?.roles?.some(r => 
    r.role.name.toLowerCase() === 'organizer'
  )

  const hasRoleManagementAccess = (roles: Session['user']['roles']) => {
    return roles?.some(r => 
      r.role.name.toLowerCase() === 'admin' || 
      r.role.name.toLowerCase() === 'organizer'
    );
  };

  // Fetch users effect
  useEffect(() => {
    const fetchUsers = async () => {
      if (status !== 'authenticated') return
      
      try {
        setIsLoading(true)
        const response = await fetch('/api/settings/users')
        const data = await response.json()
        
        if (!response.ok) throw new Error(data.error)
        setUsers(data)
      } catch (error) {
        console.error('Failed to fetch users:', error)
        toast.error('Failed to load users')
      } finally {
        setIsLoading(false)
      }
    }

    fetchUsers()
  }, [status])

  // Fetch roles effect
  useEffect(() => {
    const fetchUserData = async () => {
      if (!selectedUser) return

      try {
        const [rolesResponse, userRolesResponse] = await Promise.all([
          fetch('/api/settings/users/roles'),
          fetch(`/api/settings/users/${selectedUser.uid}/roles`)
        ])

        const [rolesData, userRolesData] = await Promise.all([
          rolesResponse.json(),
          userRolesResponse.json()
        ])

        if (!rolesResponse.ok) throw new Error('Failed to fetch available roles')
        if (!userRolesResponse.ok) throw new Error('Failed to fetch user roles')

        setAvailableRoles(rolesData || [])
        setUserRoles(userRolesData || [])
      } catch (error) {
        console.error('Failed to fetch role data:', error)
        toast.error('Failed to load role information')
        setUserRoles([])
      }
    }

    fetchUserData()
  }, [selectedUser])

  // Update form data effect
  useEffect(() => {
    if (selectedUser) {
      setFormData({
        title: selectedUser.title || '',
        firstName: selectedUser.first_name || '',
        lastName: selectedUser.surname || '',
        username: selectedUser.username || '',
        email: selectedUser.email || '',
        phone: selectedUser.cell_no || ''
      })
    }
  }, [selectedUser])

  const handleFieldChange = (field: keyof UpdateUserPayload, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value
    }))
  }

  const handleSaveUser = async (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault()
    if (!selectedUser) return


    try {
      const res = await fetch(`/api/settings/users/${selectedUser.uid}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(formData),
      })

      if (!res.ok) {
        const errData = await res.json()
        console.error('Failed to update user:', errData.error)
        return
      }

      const updated = await res.json()
      console.log('User updated successfully:', updated)

      setUsers(prev =>
        prev.map(user => 
          user.uid === selectedUser.uid 
            ? {
                ...user,
                title: updated.title,
                first_name: updated.first_name,
                surname: updated.surname,
                email: updated.email,
                username: updated.username,
                cell_no: updated.cell_no
              }
            : user
        )
      )

      setSelectedUser(null)
    } catch (error) {
      console.error('Error while updating user:', error)
    }
  }

  const handleResetPassword = () => {
    // TODO: Implement reset password functionality
    console.log('Reset Password button clicked!')
  }

  const handleRoleChange = async (roleId: string, action: 'add' | 'remove') => {
    if (!selectedUser) return

    try {
      const response = await fetch(`/api/settings/users/${selectedUser.uid}/roles`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          roleIds: [roleId], 
          action 
        }),
      })

      const data = await response.json()
      if (!response.ok) throw new Error(data.error)

      if (action === 'add') {
        const roleToAdd = availableRoles.find(role => role.uid === roleId)
        if (roleToAdd) {
          setUserRoles(prev => [...prev, roleToAdd])
        }
      } else {
        setUserRoles(prev => prev.filter(role => role.uid !== roleId))
      }

      toast.success(`Role ${action === 'add' ? 'added' : 'removed'} successfully`)
    } catch (error) {
      console.error('Failed to update user roles:', error)
      toast.error('Failed to update user roles')
    }
  }

  if (status === 'loading' || isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <p>Loading...</p>
      </div>
    )
  }

  if (status === 'unauthenticated') {
    return (
      <div className="flex items-center justify-center h-full">
        <p>Please sign in to access user settings</p>
      </div>
    )
  }

  return (
    <ScrollArea className="h-full">
      <div className="p-4">
        {selectedUser ? (
          <div className="space-y-6">
            {/* User Details Card */}
            <Card className="p-6">
              <h2 className="text-2xl font-bold mb-6">
                Edit User: {selectedUser.first_name} {selectedUser.surname}
              </h2>
              <form onSubmit={handleSaveUser} className="space-y-6">
                {/* Title and Name Fields */}
                <div className="grid grid-cols-2 gap-6">
                  <div>
                    <label htmlFor="title" className="block text-sm font-medium text-gray-700">
                      Title
                    </label>
                    <Select 
                      value={formData.title}
                      onValueChange={(value) => handleFieldChange('title', value)}
                    >
                      <SelectTrigger className="mt-1">
                        <SelectValue placeholder="Select title" />
                      </SelectTrigger>
                      <SelectContent>
                        {config.titles.map((title) => (
                          <SelectItem key={title.value} value={title.value}>
                            {title.label}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                </div>

                {/* First Name and Last Name */}
                <div className="grid grid-cols-2 gap-6">
                  <div>
                    <label htmlFor="firstName" className="block text-sm font-medium text-gray-700">
                      First Name
                    </label>
                    <Input
                      id="firstName"
                      value={formData.firstName}
                      onChange={(e) => handleFieldChange('firstName', e.target.value)}
                      className="mt-1"
                    />
                  </div>
                  <div>
                    <label htmlFor="lastName" className="block text-sm font-medium text-gray-700">
                      Last Name
                    </label>
                    <Input
                      id="lastName"
                      value={formData.lastName}
                      onChange={(e) => handleFieldChange('lastName', e.target.value)}
                      className="mt-1"
                    />
                  </div>
                </div>

                {/* Username and Reset Password */}
                <div className="grid grid-cols-2 gap-6">
                  <div>
                    <label htmlFor="username" className="block text-sm font-medium text-gray-700">
                      Username<span className="text-red-500">*</span>
                    </label>
                    <Input
                      id="username"
                      value={formData.username}
                      onChange={(e) => handleFieldChange('username', e.target.value)}
                      className="mt-1"
                    />
                  </div>
                  <div>
                    <label className="block text-sm font-medium text-gray-700">
                      Reset Password
                    </label>
                    <Button
                      variant="outline"
                      type="button"
                      className="mt-1"
                      onClick={handleResetPassword}
                    >
                      Reset Password
                    </Button>
                  </div>
                </div>


                {/* Contact Information */}
                <div className="grid grid-cols-2 gap-6">
                  <div>
                    <label htmlFor="cellNumber" className="block text-sm font-medium text-gray-700">
                      Cell Number
                    </label>
                    <Input
                      id="cellNumber"
                      value={formData.phone}
                      onChange={(e) => handleFieldChange('phone', e.target.value)}
                      className="mt-1"
                    />
                  </div>
                  <div>
                    <label htmlFor="emailAddress" className="block text-sm font-medium text-gray-700">
                      Email Address
                    </label>
                    <Input
                      id="emailAddress"
                      value={formData.email}
                      onChange={(e) => handleFieldChange('email', e.target.value)}
                      className="mt-1"
                      type="email"
                    />
                  </div>
                </div>
              </form>
            </Card>

            {selectedUser && hasRoleManagementAccess(session?.user?.roles) && (
              <Card className="p-6">
                <div className="space-y-4">
                  <h3 className="text-xl font-semibold">User Roles</h3>
                  
                  {/* Current Roles Section */}
                  <div className="space-y-2">
                    <h4 className="text-sm font-medium text-gray-700">Current Roles</h4>
                    {userRoles.length === 0 ? (
                      <p className="text-sm text-gray-500 italic">No roles assigned</p>
                    ) : (
                      <div className="space-y-2">
                        {userRoles.map((role) => (
                          <div 
                            key={role.uid}
                            className="flex items-center justify-between p-3 bg-gray-50 rounded-lg border"
                          >
                            <div>
                              <span className="font-medium">{role.role_name}</span>
                              {role.description && (
                                <p className="text-sm text-gray-500">{role.description}</p>
                              )}
                            </div>
                            <Button
                              variant="destructive"
                              size="sm"
                              onClick={() => handleRoleChange(role.uid, 'remove')}
                            >
                              Remove
                            </Button>
                          </div>
                        ))}
                      </div>
                    )}
                  </div>

                  {/* Available Roles Section */}
                  <div className="space-y-2">
                    <h4 className="text-sm font-medium text-gray-700">Available Roles</h4>
                    <div className="space-y-2">
                      {availableRoles
                        .filter(role => !userRoles.some(ur => ur.uid === role.uid))
                        .map((role) => (
                          <div 
                            key={role.uid}
                            className="flex items-center justify-between p-3 bg-white rounded-lg border"
                          >
                            <div>
                              <span className="font-medium">{role.role_name}</span>
                              {role.description && (
                                <p className="text-sm text-gray-500">{role.description}</p>
                              )}
                            </div>
                            <Button
                              variant="outline"
                              size="sm"
                              onClick={() => handleRoleChange(role.uid, 'add')}
                            >
                              Add Role
                            </Button>
                          </div>
                        ))}
                    </div>
                  </div>
                </div>
              </Card>
            )}

            {/* Action Buttons */}
            <div className="flex justify-between pt-4">
              <Button type="submit" onClick={handleSaveUser}>Save Changes</Button>
              <Button variant="outline" onClick={() => setSelectedUser(null)}>
                Back to User List
              </Button>
            </div>
          </div>
        ) : (
          <div className="space-y-4">
            <div className="flex justify-between items-center">
              <h2 className="text-2xl font-bold">User List</h2>
              {(isAdmin || isOrganizer) && (
                <Button variant="outline" onClick={() => {/* TODO: Add new user */}}>
                  Add User
                </Button>
              )}
            </div>
            {users.map((user) => (
              <Card key={user.uid} className="p-4">
                <div className="flex justify-between items-center">
                  <div>
                    <h3 className="text-lg font-semibold">
                      {user.first_name} {user.surname}
                    </h3>
                    <p className="text-sm text-gray-600">{user.email}</p>
                  </div>
                  <Button 
                    onClick={() => setSelectedUser(user)}
                    disabled={!isAdmin && !isOrganizer && user.uid !== session?.user?.id}
                  >
                    Edit
                  </Button>
                </div>
              </Card>
            ))}
          </div>
        )}
      </div>
    </ScrollArea>
  )
}
</file>

<file path="app/sites/page.tsx">
'use client'

import { useEffect, useState } from 'react'
import { useRouter } from 'next/navigation'
import { useSession } from 'next-auth/react'

export default function SitesPage() {
  const router = useRouter()
  const { data: session, status } = useSession({
    required: true,
    onUnauthenticated() {
      router.push('/login/signin')
    },
  })
  const [usernames, setUsernames] = useState<string[]>([])
  const [isLoading, setIsLoading] = useState(true)

  useEffect(() => {
    const fetchUsers = async () => {
      try {
        const response = await fetch('/api', {
          headers: {
            'Content-Type': 'application/json',
          },
        })

        if (!response.ok) {
          throw new Error('Failed to fetch users')
        }

        const data = await response.json()
        const names = data.map((user: { username: string }) => user.username).filter(Boolean)
        setUsernames(names)
      } catch (error) {
        console.error('Error fetching users:', error)
      } finally {
        setIsLoading(false)
      }
    }

    if (status === 'authenticated') {
      fetchUsers()
    }
  }, [status])

  if (status === 'loading' || isLoading) {
    return <div>Loading...</div>
  }

  return (
    <div className="container mx-auto p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Users</h1>
        <div>
          Welcome, {session?.user?.name}
        </div>
      </div>

      {usernames.length > 0 ? (
        <ul className="space-y-2">
          {usernames.map((username, index) => (
            <li 
              key={index}
              className="p-3 bg-white rounded shadow"
            >
              {username}
            </li>
          ))}
        </ul>
      ) : (
        <p>No users found.</p>
      )}
    </div>
  )
}
</file>

<file path="instrumentation.ts">
export async function register() {
  // Instrumentation code goes here
}
</file>

<file path="app/sites/file-data/page.tsx">
'use client';

import { useState, useEffect } from 'react';
import Link from 'next/link';
import { Button } from '@/app/components/ui/button';
import { Input } from '@/app/components/ui/input';
import { Card } from '@/app/components/ui/card';
import { v4 as uuidv4 } from 'uuid';
import { useParams, useRouter } from 'next/navigation';

export default function FileDataListPage() {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [searchQuery, setSearchQuery] = useState('');
  const { uid } = useParams();
  const router = useRouter();

  useEffect(() => {
    async function fetchFiles() {
      console.log('%c🚀 Frontend: Starting file fetch', 'color: blue; font-weight: bold');
      try {
        const response = await fetch('/api/files');
        console.log(`%c📡 Frontend: API response status: ${response.status}`, 'color: cyan');
        
        const data = await response.json();
        console.log('%c📦 Frontend: Raw response data:', 'color: green', data);
        console.log(`%c🔍 Frontend: Is data an array? ${Array.isArray(data)}`, 'color: green');
        console.log(`%c📊 Frontend: Data length: ${Array.isArray(data) ? data.length : "N/A"}`, 'color: green');
        
        if (Array.isArray(data)) {
          const withPatient = data.filter(file => file.patient?.id || file.patient?.name);
          const withoutPatient = data.filter(file => !file.patient?.id && !file.patient?.name);
          console.log(`%c👤 Frontend: Files with patient data: ${withPatient.length}`, 'color: orange');
          console.log(`%c🚶 Frontend: Files without patient data: ${withoutPatient.length}`, 'color: orange');
        }
        
        // Ensure we always have an array
        setFiles(Array.isArray(data) ? data : []);
        console.log('%c✅ Frontend: State updated with file data', 'color: green; font-weight: bold');
      } catch (error) {
        console.error('%c❌ Frontend: Failed to fetch files:', 'color: red; font-weight: bold', error);
        setFiles([]);
      } finally {
        setLoading(false);
        console.log('%c🏁 Frontend: Loading state set to false', 'color: blue');
      }
    }
    
    fetchFiles();
  }, []);
  
  // Make sure we have an array before filtering
  console.log('%c📂 Frontend: Current files state before filtering:', 'color: purple', files);
  console.log(`%c🔍 Frontend: Is files state an array? ${Array.isArray(files)}`, 'color: purple');

  const filteredFiles = Array.isArray(files) 
    ? files.filter(file => {
        // Handle case where search query is empty (show all files)
        if (!searchQuery) return true;
        
        // Define what fields we're searching in, handling possible null/undefined values
        const fileNumber = file.file_number?.toLowerCase() || '';
        const accountNumber = file.account_number?.toLowerCase() || '';
        const patientId = file.patient?.id?.toLowerCase() || '';
        const patientName = file.patient?.name?.toLowerCase() || '';
        
        const query = searchQuery.toLowerCase();
        
        const matchesFileNumber = fileNumber.includes(query);
        const matchesAccountNumber = accountNumber.includes(query);
        const matchesPatientId = patientId.includes(query);
        const matchesPatientName = patientName.includes(query);
        
        if (searchQuery) {
          console.log('%c🔎 Frontend: Filtering file:', 'color: orange', {
            uid: file.uid,
            file_number: file.file_number,
            matchesFileNumber,
            matchesAccountNumber,
            matchesPatientId,
            matchesPatientName
          });
        }
        
        return matchesFileNumber || matchesAccountNumber || matchesPatientId || matchesPatientName;
      })
    : [];

  console.log(`%c📊 Frontend: Filtered files count: ${filteredFiles.length}`, 'color: green; font-weight: bold');
  
  const handleCreateNew = () => {
    window.location.href = `/sites/file-data/new-record`;
  };
  
  return (
    <div className="container mx-auto py-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">File Data</h1>
        <Button onClick={handleCreateNew}>Create New</Button>
      </div>
      
      <Card className="p-4 mb-6">
        <div className="flex gap-4">
          <div className="flex-1">
            <Input
              placeholder="Search by file number, account number, ID or patient name"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full"
            />
          </div>
        </div>
      </Card>
      
      {loading ? (
        <p>Loading...</p>
      ) : filteredFiles.length > 0 ? (
        <div className="bg-white shadow rounded-lg overflow-hidden">
          <table className="min-w-full divide-y divide-gray-200">
            <thead className="bg-gray-50">
              <tr>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  File Number
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Account Number
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Patient ID
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Patient Name
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Gender
                </th>
                <th className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                  Actions
                </th>
              </tr>
            </thead>
            <tbody className="bg-white divide-y divide-gray-200">
              {filteredFiles.map((file) => (
                <tr key={file.uid} className="hover:bg-gray-50">
                  <td className="px-6 py-4 whitespace-nowrap">{file.file_number || '-'}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{file.account_number || '-'}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{file.patient?.id || '-'}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{file.patient?.name || '-'}</td>
                  <td className="px-6 py-4 whitespace-nowrap">{file.patient?.gender || '-'}</td>
                  <td className="px-6 py-4 whitespace-nowrap">
                    <Link 
                      href={`/sites/file-data/${file.uid}`}
                      className="text-indigo-600 hover:text-indigo-900"
                    >
                      View
                    </Link>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>
      ) : (
        <div className="text-center py-8">
          <p className="text-gray-500">No Records found</p>
        </div>
      )}
    </div>
  );
}
</file>

<file path="app/sites/settings/page.tsx">
'use client'

import { useSession } from "next-auth/react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/app/components/ui/tabs"
import { GeneralSettings } from "./GeneralSettings"
import { UserSettings } from "./UserSettings"
import { DebitOrderSettings } from "./DebitOrderSettings"

export default function SettingsPage() {
  const { data: session } = useSession()

  // Helper function to check if user has admin or organizer role
  const hasAdminAccess = session?.user?.roles?.some(r => 
    r.role.name.toLowerCase() === 'admin' || 
    r.role.name.toLowerCase() === 'organizer'
  )

  // If user doesn't have admin access, they can only see user settings
  const defaultTab = hasAdminAccess ? "general" : "users"

  return (
    <div className="h-full">
      <Tabs defaultValue={defaultTab} className="flex h-full">
        <div className="w-64 border-r bg-gray-50">
          <TabsList className="flex h-full w-full flex-col items-stretch gap-1 bg-transparent p-2">
            {hasAdminAccess && (
              <TabsTrigger
                value="general"
                className="justify-start data-[state=active]:bg-white"
              >
                General
              </TabsTrigger>
            )}
            <TabsTrigger
              value="users"
              className="justify-start data-[state=active]:bg-white"
            >
              Users
            </TabsTrigger>
            {hasAdminAccess && (
              <TabsTrigger
                value="debit-order"
                className="justify-start data-[state=active]:bg-white"
              >
                Debit Order
              </TabsTrigger>
            )}
          </TabsList>
        </div>

        <div className="flex-1">
          {hasAdminAccess && (
            <TabsContent value="general" className="h-full m-0 border-0">
              <GeneralSettings />
            </TabsContent>
          )}

          <TabsContent value="users" className="h-full m-0 border-0">
            <UserSettings />
          </TabsContent>

          {hasAdminAccess && (
            <TabsContent value="debit-order" className="h-full m-0 border-0">
              <DebitOrderSettings />
            </TabsContent>
          )}
        </div>
      </Tabs>
    </div>
  )
}
</file>

<file path="prisma/schema.prisma">
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model file_info {
  uid                            String                           @id @db.Uuid
  file_number                    String?                          @db.VarChar(255)
  account_number                 String?                          @db.VarChar(255)
  billing_account_no             String?                          @db.VarChar(255)
  referral_doc_name              String?                          @db.VarChar(255)
  referral_doc_number            String?                          @db.VarChar(255)
  consent1                       Boolean?
  consent2                       Boolean?
  consent3                       Boolean?
  orgid                          String?                          @db.Uuid
  active                         Boolean?
  date_created                   DateTime?                        @db.Timestamp(6)
  last_edit                      DateTime?                        @db.Timestamp(6)
  locked                         Boolean?
  organization_info              organization_info?               @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "file_info_organization_info_fk")
  fileinfo_patient               fileinfo_patient[]
  injury_on_duty                 injury_on_duty[]
  patient_medical_aid            patient_medical_aid[]
  patientmedicalaid_file_patient patientmedicalaid_file_patient[]
  person_responsible             person_responsible[]
}

model fileinfo_patient {
  uid               String             @id @db.Uuid
  patientid         String?            @db.Uuid
  fileid            String?            @db.Uuid
  orgid             String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  file_info         file_info?         @relation(fields: [fileid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "fileinfo_patient_file_info_fk")
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "fileinfo_patient_organization_info_fk")
  patient           patient?           @relation(fields: [patientid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "fileinfo_patient_patient_fk")
  tab_notes         tab_notes[]
}

model injury_on_duty {
  uid               String             @id @db.Uuid
  company_name      String?            @db.VarChar(255)
  contact_person    String?            @db.VarChar(255)
  contact_number    String?            @db.VarChar(255)
  contact_email     String?            @db.VarChar(255)
  created_date      DateTime?          @db.Timestamp(6)
  fileid            String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  orgid             String?            @db.Uuid
  locked            Boolean?
  file_info         file_info?         @relation(fields: [fileid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "injury_on_duty_file_info_fk")
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "injury_on_duty_organization_info_fk")
}

model logo_table {
  uid               String             @id @db.Uuid
  filename          String?            @db.VarChar(255)
  file_location     String?
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  orgid             String?            @db.Uuid
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "logo_table_organization_info_fk")
}

model medical_scheme {
  uid                 String                @id @db.Uuid
  scheme_name         String?               @db.VarChar(255)
  active              Boolean?
  date_created        DateTime?             @db.Timestamp(6)
  last_edit           DateTime?             @db.Timestamp(6)
  orgid               String?               @db.Uuid
  locked              Boolean?
  patient_medical_aid patient_medical_aid[]
}

model notifications {
  uid               String             @id @db.Uuid
  orgid             String?            @db.Uuid
  type              String?            @db.VarChar(255)
  time_stamp        DateTime?          @db.Timestamp(6)
  destination       String?            @db.VarChar(255)
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "notifications_organization_info_fk")
}

model organization_info {
  uid                                 String                           @id @db.Uuid
  practice_name                       String?                          @db.VarChar(255)
  bhf_number                          String?                          @db.VarChar(255)
  hpcsa                               String?                          @db.VarChar(255)
  practice_type                       String?                          @db.VarChar(255)
  vat_no                              String?                          @db.VarChar(255)
  address                             String?
  postal                              String?
  practice_telephone                  String?                          @db.VarChar(255)
  accounts_telephone                  String?                          @db.VarChar(255)
  cell                                String?                          @db.VarChar(255)
  fax                                 String?                          @db.VarChar(255)
  email                               String?                          @db.VarChar(255)
  consent_to_treatment                String?
  consent_to_financial_responsibility String?
  consent_to_release_of_information   String?
  active                              Boolean?
  date_created                        DateTime?                        @db.Timestamp(6)
  last_edit                           DateTime?                        @db.Timestamp(6)
  locked                              Boolean?
  file_info                           file_info[]
  fileinfo_patient                    fileinfo_patient[]
  injury_on_duty                      injury_on_duty[]
  logo_table                          logo_table[]
  notifications                       notifications[]
  organization_payment_details        organization_payment_details[]
  patient                             patient[]
  patient_medical_aid                 patient_medical_aid[]
  patientmedicalaid_file_patient      patientmedicalaid_file_patient[]
  person_responsible                  person_responsible[]
  signature                           signature[]
  tab_files                           tab_files[]
  tab_notes                           tab_notes[]
  user_calendar_entries               user_calendar_entries[]
  user_roles                          user_roles[]
  users                               users[]
}

model organization_payment_details {
  uid               String             @id @db.Uuid
  orgid             String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "organization_payment_details_organization_info_fk")
}

model patient {
  uid                            String                           @id @db.Uuid
  orgid                          String?                          @db.Uuid
  id                             String?                          @db.VarChar(255)
  title                          String?                          @db.VarChar(255)
  name                           String?                          @db.VarChar(255)
  initials                       String?                          @db.VarChar(255)
  surname                        String?                          @db.VarChar(255)
  date_of_birth                  DateTime?                        @db.Date
  gender                         String?                          @db.VarChar(255)
  cell_phone                     String?                          @db.VarChar(255)
  additional_name                String?                          @db.VarChar(255)
  additional_cell                String?                          @db.VarChar(255)
  email                          String?                          @db.VarChar(255)
  address                        String?
  active                         Boolean?
  date_created                   DateTime?                        @db.Timestamp(6)
  last_edit                      DateTime?                        @db.Timestamp(6)
  locked                         Boolean?
  fileinfo_patient               fileinfo_patient[]
  organization_info              organization_info?               @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patient_organization_info_fk")
  patientmedicalaid_file_patient patientmedicalaid_file_patient[]
  person_responsible             person_responsible[]
  tab_notes                      tab_notes[]
}

model patient_medical_aid {
  uid                            String                           @id @db.Uuid
  medical_scheme_id              String?                          @db.Uuid
  membership_number              String?                          @db.VarChar(255)
  patient_dependant_code         String?                          @db.VarChar(255)
  patient_or_not                 String?                          @db.VarChar(255)
  fileid                         String?                          @db.Uuid
  active                         Boolean?
  date_created                   DateTime?                        @db.Timestamp(6)
  last_edit                      DateTime?                        @db.Timestamp(6)
  orgid                          String?                          @db.Uuid
  locked                         Boolean?
  file_info                      file_info?                       @relation(fields: [fileid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patient_medical_aid_file_info_fk")
  medical_scheme                 medical_scheme?                  @relation(fields: [medical_scheme_id], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patient_medical_aid_medical_scheme_fk")
  organization_info              organization_info?               @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patient_medical_aid_organization_info_fk")
  patientmedicalaid_file_patient patientmedicalaid_file_patient[]
}

model patientmedicalaid_file_patient {
  uid                    String               @id @db.Uuid
  patient_medical_aid_id String?              @db.Uuid
  fileid                 String?              @db.Uuid
  patientid              String?              @db.Uuid
  active                 Boolean?
  date_created           DateTime?            @db.Timestamp(6)
  last_edit              DateTime?            @db.Timestamp(6)
  orgid                  String?              @db.Uuid
  locked                 Boolean?
  file_info              file_info?           @relation(fields: [fileid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patientmedicalaid_file_patient_file_info_fk")
  organization_info      organization_info?   @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patientmedicalaid_file_patient_organization_info_fk")
  patient                patient?             @relation(fields: [patientid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patientmedicalaid_file_patient_patient_fk")
  patient_medical_aid    patient_medical_aid? @relation(fields: [patient_medical_aid_id], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "patientmedicalaid_file_patient_patient_medical_aid_fk")
}

model person_responsible {
  uid               String             @id @db.Uuid
  orgid             String?            @db.Uuid
  person_type       String?            @db.VarChar(255)
  fileid            String?            @db.Uuid
  personid          String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  file_info         file_info?         @relation(fields: [fileid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "person_responsible_file_info_fk")
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "person_responsible_organization_info_fk")
  patient           patient?           @relation(fields: [personid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "person_responsible_patient_fk")
}

model roles {
  uid          String       @id @db.Uuid
  role_name    String?      @db.VarChar(255)
  description  String?
  active       Boolean?
  date_created DateTime?    @db.Timestamp(6)
  last_edit    DateTime?    @db.Timestamp(6)
  locked       Boolean?
  user_roles   user_roles[]
}

model signature {
  uid               String             @id @db.Uuid
  userid            String?            @db.Uuid
  filename          String?            @db.VarChar(255)
  file_location     String?
  orgid             String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "signature_organization_info_fk")
  users             users?             @relation(fields: [userid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "signature_users_fk")
}

model tab_files {
  uid               String             @id @db.Uuid
  orgid             String?            @db.Uuid
  tab_notes_id      String?            @db.Uuid
  file_name         String?            @db.VarChar(255)
  file_type         String?            @db.VarChar(255)
  file_location     String?
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "tab_files_organization_info_fk")
  tab_notes         tab_notes?         @relation(fields: [tab_notes_id], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "tab_files_tab_notes_fk")
}

model tab_notes {
  uid                 String             @id @db.Uuid
  orgid               String?            @db.Uuid
  fileinfo_patient_id String?            @db.Uuid
  personid            String?            @db.Uuid
  time_stamp          DateTime?          @db.Timestamp(6)
  notes               String?
  tab_type            String?            @db.VarChar(255)
  active              Boolean?
  date_created        DateTime?          @db.Timestamp(6)
  last_edit           DateTime?          @db.Timestamp(6)
  locked              Boolean?
  tab_files           tab_files[]
  fileinfo_patient    fileinfo_patient?  @relation(fields: [fileinfo_patient_id], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "tab_notes_fileinfo_patient_fk")
  organization_info   organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "tab_notes_organization_info_fk")
  patient             patient?           @relation(fields: [personid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "tab_notes_patient_fk")
}

model user_calendar_entries {
  uid               String             @id @db.Uuid
  user_uid          String?            @db.Uuid
  startdate         DateTime?          @db.Timestamp(6)
  length            Int?
  description       String?            @db.VarChar(255)
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  orgid             String?            @db.Uuid
  locked            Boolean?
  enddate           DateTime?          @db.Timestamp(6)
  title             String?            @db.VarChar(255)
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "user_calendar_entries_organization_info_fk")
  users             users?             @relation(fields: [user_uid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "user_calendar_entries_users_fk")
}

model user_roles {
  uid               String             @id @db.Uuid
  userid            String?            @db.Uuid
  roleid            String?            @db.Uuid
  orgid             String?            @db.Uuid
  active            Boolean?
  date_created      DateTime?          @db.Timestamp(6)
  last_edit         DateTime?          @db.Timestamp(6)
  locked            Boolean?
  organization_info organization_info? @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "user_roles_organization_info_fk")
  roles             roles?             @relation(fields: [roleid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "user_roles_roles_fk")
  users             users?             @relation(fields: [userid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "user_roles_users_fk")
}

model users {
  uid                   String                  @id @db.Uuid
  title                 String?                 @db.VarChar(255)
  first_name            String?                 @db.VarChar(255)
  surname               String?                 @db.VarChar(255)
  cell_no               String?                 @db.VarChar(255)
  secret_key            String?                 @db.VarChar(255)
  email                 String?                 @db.VarChar(255)
  username              String?                 @db.VarChar(255)
  login_key             String?                 @db.VarChar(255)
  active                Boolean?
  date_created          DateTime?               @db.Timestamp(6)
  last_edit             DateTime?               @db.Timestamp(6)
  orgid                 String?                 @db.Uuid
  locked                Boolean?
  signature             signature[]
  user_calendar_entries user_calendar_entries[]
  user_roles            user_roles[]
  organization_info     organization_info?      @relation(fields: [orgid], references: [uid], onDelete: NoAction, onUpdate: NoAction, map: "users_organization_info_fk")
}

model Practice_Types {
  uuid         String    @id @db.Uuid
  codes        String?
  name         String?
  active       Boolean?
  last_edit    DateTime? @db.Timestamp(6)
  date_created DateTime? @db.Timestamp(6)
}
</file>

<file path="next.config.js">
/** @type {import('next').NextConfig} */
const nextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'qisxkjvaehtwayccikyj.supabase.co',
        pathname: '/storage/v1/object/public/**',
      },
    ],
  },
  experimental: {
    serverExternalPackages: ["next-auth"],
    typedRoutes: false,
  },
  typescript: {
    // !! WARN !!
    // This will allow production builds to successfully complete
    // even if your project has type errors.
    // !! WARN !!
    ignoreBuildErrors: true,
  },
}

module.exports = nextConfig
</file>

<file path="app/api/route.ts">
'use server'

import { NextResponse } from 'next/server'
import { auth } from "@/app/actions/auth"
import prisma from '@/app/lib/prisma'

export async function GET() {
  try {
    // Verify authentication
    const session = await auth()
    if (!session) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    const users = await prisma.users.findMany({
      where: {
        AND: [
          { active: true },
          { orgid: session.user.orgId } // Use the organization ID from the session
        ]
      },
      select: {
        username: true
      }
    })
    
    return NextResponse.json(users)
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' + error }, 
      { status: 500 }
    )
  }
}

export async function POST() {
  return NextResponse.json({ message: 'Method not allowed' }, { status: 405 })
}
</file>

<file path="app/page.tsx">
'use client'

import { useState, useEffect } from 'react';
import { motion } from 'framer-motion';
import { FileText, Shield, Clock, Users } from 'lucide-react';

export default function LandingPage() {
  const [isVisible, setIsVisible] = useState(false);

  useEffect(() => {
    setIsVisible(true);
  }, []);

  const fadeIn = {
    hidden: { opacity: 0, y: 20 },
    visible: { opacity: 1, y: 0 }
  };

  const stagger = {
    hidden: { opacity: 0 },
    visible: {
      opacity: 1,
      transition: {
        staggerChildren: 0.2
      }
    }
  };

  return (
    <div className="min-h-screen bg-white">
      {/* Navbar */}
      <nav className="fixed w-full bg-white/80 backdrop-blur-md z-50 shadow-sm">
        <div className="container mx-auto px-6 py-4">
          <div className="flex items-center justify-between">
            <motion.div
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              className="text-2xl font-bold text-sky-500"
            >
              DigiFile
            </motion.div>
            <div className="hidden md:flex space-x-8">
              <a href="#features" className="text-gray-600 hover:text-sky-500 transition-colors">Features</a>
              <a href="#about" className="text-gray-600 hover:text-sky-500 transition-colors">About</a>
              <a href="#contact" className="text-gray-600 hover:text-sky-500 transition-colors">Contact</a>
            </div>
            <motion.button
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="bg-sky-500 text-white px-6 py-2 rounded-full hover:bg-sky-600 transition-colors"
              onClick={() => window.location.href = '/login/signin'}
            >
              Get Started
            </motion.button>
          </div>
        </div>
      </nav>

      {/* Hero Section */}
      <section className="pt-32 pb-20 bg-gradient-to-b from-sky-50 to-white">
        <div className="container mx-auto px-6">
          <motion.div
            initial="hidden"
            animate={isVisible ? "visible" : "hidden"}
            variants={fadeIn}
            className="text-center"
          >
            <motion.h1 
              className="text-6xl md:text-7xl font-bold text-gray-900 mb-6"
              initial={{ scale: 0.5, opacity: 0 }}
              animate={{ scale: 1, opacity: 1 }}
              transition={{ duration: 0.5 }}
            >
              <span className="text-sky-500">Digi</span>File
            </motion.h1>
            <motion.p
              className="text-xl text-gray-600 mb-8 max-w-2xl mx-auto"
              variants={fadeIn}
            >
              Transform your medical practice with our innovative digital filing system.
              Secure, efficient, and designed for healthcare professionals.
            </motion.p>
            <motion.div
              className="flex justify-center gap-4"
              variants={fadeIn}
            >
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                className="bg-sky-500 text-white px-8 py-3 rounded-full text-lg hover:bg-sky-600 transition-colors"
              >
                Contact Us
              </motion.button>
              <motion.button
                whileHover={{ scale: 1.05 }}
                whileTap={{ scale: 0.95 }}
                className="border-2 border-sky-500 text-sky-500 px-8 py-3 rounded-full text-lg hover:bg-sky-50 transition-colors"
              >
                Learn More
              </motion.button>
            </motion.div>
          </motion.div>
        </div>
      </section>

      {/* Features Section */}
      <section className="py-20" id="features">
        <div className="container mx-auto px-6">
          <motion.div
            initial="hidden"
            whileInView="visible"
            viewport={{ once: true }}
            variants={stagger}
            className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-8"
          >
            <motion.div
              variants={fadeIn}
              className="p-6 bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow"
            >
              <FileText className="w-12 h-12 text-sky-500 mb-4" />
              <h3 className="text-xl font-semibold mb-2">Digital Records</h3>
              <p className="text-gray-600">Secure digital storage for all your medical records</p>
            </motion.div>

            <motion.div
              variants={fadeIn}
              className="p-6 bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow"
            >
              <Shield className="w-12 h-12 text-sky-500 mb-4" />
              <h3 className="text-xl font-semibold mb-2">POPIA Compliant</h3>
              <p className="text-gray-600">Full compliance with healthcare privacy standards</p>
            </motion.div>

            <motion.div
              variants={fadeIn}
              className="p-6 bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow"
            >
              <Clock className="w-12 h-12 text-sky-500 mb-4" />
              <h3 className="text-xl font-semibold mb-2">Real-time Access</h3>
              <p className="text-gray-600">Instant access to patient information</p>
            </motion.div>

            <motion.div
              variants={fadeIn}
              className="p-6 bg-white rounded-xl shadow-lg hover:shadow-xl transition-shadow"
            >
              <Users className="w-12 h-12 text-sky-500 mb-4" />
              <h3 className="text-xl font-semibold mb-2">Team Collaboration</h3>
              <p className="text-gray-600">Seamless sharing between healthcare providers</p>
            </motion.div>
          </motion.div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20 bg-sky-500">
        <div className="container mx-auto px-6">
          <motion.div
            initial="hidden"
            whileInView="visible"
            viewport={{ once: true }}
            variants={fadeIn}
            className="text-center text-white"
          >
            <h2 className="text-4xl font-bold mb-6">Ready to Transform Your Practice?</h2>
            <p className="text-xl mb-8 opacity-90">Join thousands of healthcare professionals already using DigiFile</p>
            <motion.button
              whileHover={{ scale: 1.05 }}
              whileTap={{ scale: 0.95 }}
              className="bg-white text-sky-500 px-8 py-3 rounded-full text-lg hover:bg-sky-50 transition-colors"
              onClick={() => window.location.href = '/login/signin'}
            >
              Get Started Now
            </motion.button>
          </motion.div>
        </div>
      </section>

      {/* Footer */}
      <footer className="bg-gray-50 py-12">
        <div className="container mx-auto px-6">
          <div className="grid grid-cols-1 md:grid-cols-4 gap-8">
            <div>
              <h3 className="text-xl font-bold text-sky-500 mb-4">DigiFile</h3>
              <p className="text-gray-600">Transforming healthcare through digital innovation</p>
            </div>
            <div>
              <h4 className="font-semibold mb-4">Product</h4>
              <ul className="space-y-2 text-gray-600">
                <li>Features</li>
                <li>Pricing</li>
                <li>Security</li>
              </ul>
            </div>
            <div>
              <h4 className="font-semibold mb-4">Company</h4>
              <ul className="space-y-2 text-gray-600">
                <li>About Us</li>
                <li>Careers</li>
                <li>Contact</li>
              </ul>
            </div>
            <div>
              <h4 className="font-semibold mb-4">Legal</h4>
              <ul className="space-y-2 text-gray-600">
                <li>Privacy Policy</li>
                <li>Terms of Service</li>
                <li>POPIA Compliance</li>
              </ul>
            </div>
          </div>
          <div className="mt-12 pt-8 border-t border-gray-200 text-center text-gray-600">
            <p>&copy; 2024 DigiFile. All rights reserved.</p>
          </div>
        </div>
      </footer>
    </div>
  );
}
</file>

<file path="app/sites/calendar/page.tsx">
"use client"

import { Calendar } from "@/app/components/ui/calendar"
import { Account, CalendarEvent } from "@/app/types/calendar"
import { useEffect, useState, useCallback } from "react"
import { useSession } from "next-auth/react"

export default function CalendarPage() {
  const { data: session } = useSession()
  const [accounts, setAccounts] = useState<Account[]>([])
  const [events, setEvents] = useState<CalendarEvent[]>([])
  const [selectedAccounts, setSelectedAccounts] = useState<string[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  // Ensure hasAdminAccess is always a boolean
  const hasAdminAccess = !!session?.user?.roles?.some(r =>
    r.role.name.toLowerCase() === "admin" ||
    r.role.name.toLowerCase() === "organizer"
  )

  const fetchCalendarData = useCallback(async () => {
    try {
      const response = await fetch("/api/calendar", {
        headers: {
          "Content-Type": "application/json",
        },
      })
      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || "Failed to fetch calendar data")
      }

      setAccounts(data.accounts)
      setEvents(data.events)
    } catch (error) {
      console.error("Error fetching calendar data:", error)
      setError(error instanceof Error ? error.message : "Failed to load calendar data.")
      throw error
    }
  }, [])

  // Initial load
  useEffect(() => {
    const initializeCalendar = async () => {
      setIsLoading(true)
      try {
        if (session?.user?.id) {
          setSelectedAccounts([session.user.id])
          await fetchCalendarData()
        }
      } catch (error) {
        console.error("Error initializing calendar:", error)
      } finally {
        setIsLoading(false)
      }
    }

    initializeCalendar()
  }, [session?.user?.id, fetchCalendarData])

  const handleAccountToggle = (accountId: string) => {
    setSelectedAccounts((current) =>
      current.includes(accountId)
        ? current.filter((id) => id !== accountId)
        : [...current, accountId]
    )
  }

  if (isLoading) {
    return <div className="flex items-center justify-center h-full">Loading...</div>
  }

  if (error) {
    return <div className="flex items-center justify-center h-full text-red-500">{error}</div>
  }

  return (
    <div className="container mx-auto py-6 px-4">
      <div className="bg-gray-50 rounded-xl p-6">
        <Calendar
          accounts={accounts}
          events={events}
          refreshData={fetchCalendarData}
          hasAdminAccess={hasAdminAccess}
          defaultSelectedAccount={session?.user?.id}
          selectedAccounts={selectedAccounts}
          onToggleAccount={handleAccountToggle}
        />
      </div>
    </div>
  )
}
</file>

<file path="app/sites/file-data/[uid]/page.tsx">
'use client';

import { useState, useEffect, useRef } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { Card } from '@/app/components/ui/card';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/app/components/ui/tabs';
import { Input } from '@/app/components/ui/input';
import { Label } from '@/app/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/app/components/ui/select';
import { Calendar } from '@/app/components/ui/calendar';
import { CalendarIcon, Search, Plus, ArrowUpDown, Upload, X } from 'lucide-react';
import { format } from 'date-fns';
import { Popover, PopoverContent, PopoverTrigger } from '@/app/components/ui/popover';
import { Editor } from '@/app/components/ui/editor';
import { RadioGroup, RadioGroupItem } from '@/app/components/ui/radio-group';
import { Checkbox } from '@/app/components/ui/checkbox';
import { Button } from '@/app/components/ui/button';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogFooter } from '@/app/components/ui/dialog';
import { Textarea } from '@/app/components/ui/textarea';

export default function FileDataPage() {
  const { uid } = useParams();
  const router = useRouter();
  const [file, setFile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const isNewRecord = uid === 'new-record';
  const [extraInfo, setExtraInfo] = useState(file?.extraInfo || '');
  const [coverType, setCoverType] = useState('medical-aid');
  const [sameAsPatient, setSameAsPatient] = useState(false);

  // References for date input fields
  const yearInputRef = useRef(null);
  const monthInputRef = useRef(null);
  const dayInputRef = useRef(null);
  
  // References for member date fields
  const memberYearInputRef = useRef(null);
  const memberMonthInputRef = useRef(null);
  const memberDayInputRef = useRef(null);
  
  // Separate state for date parts
  const [dateOfBirth, setDateOfBirth] = useState({
    year: '',
    month: '',
    day: ''
  });
  
  // Separate state for member date parts
  const [memberDateOfBirth, setMemberDateOfBirth] = useState({
    year: '',
    month: '',
    day: ''
  });
  
  // Add new states for member info
  const [memberGender, setMemberGender] = useState('');

  // Add state for medical schemes
  const [medicalSchemes, setMedicalSchemes] = useState([]);

  // Add new state for notes filtering
  const [searchQuery, setSearchQuery] = useState('');
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);
  const [sortOrder, setSortOrder] = useState('desc'); // 'desc' = newest first, 'asc' = oldest first

  // New state for the note modal
  const [isNoteModalOpen, setIsNoteModalOpen] = useState(false);
  const [activeNoteTab, setActiveNoteTab] = useState(''); // 'file' or 'clinical'
  const [noteDateTime, setNoteDateTime] = useState(new Date());
  const [noteContent, setNoteContent] = useState('');
  const [uploadedFiles, setUploadedFiles] = useState([]);
  const fileInputRef = useRef(null);

  // Initialize date parts from file data if available
  useEffect(() => {
    if (file?.patient?.dob && typeof file.patient.dob === 'string') {
      // Parse existing date if available
      const dateParts = file.patient.dob.split('/');
      if (dateParts.length === 3) {
        setDateOfBirth({
          year: dateParts[0],
          month: dateParts[1],
          day: dateParts[2]
        });
      }
    }
    
    // Initialize medical cover type if available
    if (file?.medical_cover?.type) {
      setCoverType(file.medical_cover.type);
    }
    
    // Initialize same as patient checkbox if available
    if (file?.medical_cover?.same_as_patient) {
      setSameAsPatient(file.medical_cover.same_as_patient);
    }
    
    // Initialize member date of birth if available
    if (file?.medical_cover?.member?.dob && typeof file.medical_cover.member.dob === 'string') {
      const dateParts = file.medical_cover.member.dob.split('/');
      if (dateParts.length === 3) {
        setMemberDateOfBirth({
          year: dateParts[0],
          month: dateParts[1],
          day: dateParts[2]
        });
      }
    }
  }, [file]);

  // Handle date part changes with validation and auto-focus
  const handleDatePartChange = (part: 'year' | 'month' | 'day', value: string, maxLength: number, nextRef?: React.RefObject<HTMLInputElement>) => {
    // Only allow numbers
    if (!/^\d*$/.test(value)) return;
    
    // Apply appropriate validations
    if (part === 'month' && value.length === 2 && parseInt(value) > 12) {
      value = '12';
    }
    
    if (part === 'day' && value.length === 2 && parseInt(value) > 31) {
      value = '31';
    }
    
    // Update the date part
    setDateOfBirth(prev => ({ ...prev, [part]: value }));
    
    // Update the patient DOB in the file state
    const newDob = part === 'year' 
      ? `${value}/${dateOfBirth.month}/${dateOfBirth.day}`
      : part === 'month'
      ? `${dateOfBirth.year}/${value}/${dateOfBirth.day}`
      : `${dateOfBirth.year}/${dateOfBirth.month}/${value}`;
    
    setFile({
      ...file,
      patient: {
        ...file.patient,
        dob: newDob
      }
    });
    
    // Auto-focus to next field when max length is reached
    if (value.length === maxLength && nextRef?.current) {
      nextRef.current.focus();
    }
  };
  
  // Handle member date part changes with validation and auto-focus
  const handleMemberDatePartChange = (part: 'year' | 'month' | 'day', value: string, maxLength: number, nextRef?: React.RefObject<HTMLInputElement>) => {
    // Only allow numbers
    if (!/^\d*$/.test(value)) return;
    
    // Apply appropriate validations
    if (part === 'month' && value.length === 2 && parseInt(value) > 12) {
      value = '12';
    }
    
    if (part === 'day' && value.length === 2 && parseInt(value) > 31) {
      value = '31';
    }
    
    // Update the date part
    setMemberDateOfBirth(prev => ({ ...prev, [part]: value }));
    
    // Update the member DOB in the file state
    const newDob = part === 'year' 
      ? `${value}/${memberDateOfBirth.month}/${memberDateOfBirth.day}`
      : part === 'month'
      ? `${memberDateOfBirth.year}/${value}/${memberDateOfBirth.day}`
      : `${memberDateOfBirth.year}/${memberDateOfBirth.month}/${value}`;
    
    setFile({
      ...file,
      medical_cover: {
        ...file.medical_cover,
        member: {
          ...file.medical_cover?.member,
          dob: newDob
        }
      }
    });
    
    // Auto-focus to next field when max length is reached
    if (value.length === maxLength && nextRef?.current) {
      nextRef.current.focus();
    }
  };
  
  // Handle medical cover type change
  const handleCoverTypeChange = (value: string) => {
    setCoverType(value);
    
    // Update file state
    setFile({
      ...file,
      medical_cover: {
        ...file.medical_cover,
        type: value
      }
    });
  };
  
  // Handle same as patient checkbox change
  const handleSameAsPatientChange = (checked: boolean) => {
    setSameAsPatient(checked);
    
    // Update file state
    setFile({
      ...file,
      medical_cover: {
        ...file.medical_cover,
        same_as_patient: checked
      }
    });
  };

  // Function to handle input changes for patient data
  const handlePatientInputChange = (field, value) => {
    console.log(`Updating patient.${field} to:`, value);
    
    // Special handling for ID number - extract and populate date of birth
    if (field === 'id' && value.length >= 6) {
      const idNumber = value;
      const yearPart = idNumber.substring(0, 2);
      const monthPart = idNumber.substring(2, 4);
      const dayPart = idNumber.substring(4, 6);
      
      // Determine the century
      const currentYear = new Date().getFullYear();
      const currentCentury = Math.floor(currentYear / 100);
      const currentYearLastTwo = currentYear % 100;
      
      // If the year part is greater than the current year's last two digits,
      // it's likely from the previous century
      const fullYear = parseInt(yearPart) > currentYearLastTwo
        ? `${currentCentury - 1}${yearPart}`
        : `${currentCentury}${yearPart}`;
      
      // Update date of birth fields
      setDateOfBirth({
        year: fullYear,
        month: monthPart,
        day: dayPart
      });
      
      // Update the file state with the extracted DOB
      setFile(prevFile => ({
        ...prevFile,
        patient: {
          ...prevFile.patient,
          [field]: value,
          dob: `${fullYear}/${monthPart}/${dayPart}`
        }
      }));
      return;
    }
    
    // Special handling for name - auto-generate initials
    if (field === 'name' || field === 'surname') {
      setFile(prevFile => {
        const newName = field === 'name' ? value : prevFile.patient?.name || '';
        const newSurname = field === 'surname' ? value : prevFile.patient?.surname || '';
        
        // Generate initials from name and surname
        let initials = '';
        if (newName) {
          // Split by spaces in case there's a middle name
          const nameParts = newName.split(' ');
          nameParts.forEach(part => {
            if (part.trim()) {
              initials += part.charAt(0).toUpperCase() + '.';
            }
          });
        }
        
        if (newSurname) {
          initials += newSurname.charAt(0).toUpperCase() + '.';
        }
        
        return {
          ...prevFile,
          patient: {
            ...prevFile.patient,
            [field]: value,
            initials: initials.trim()
          }
        };
      });
      return;
    }
    
    // Standard handling for other fields
    setFile(prevFile => ({
      ...prevFile,
      patient: {
        ...prevFile.patient,
        [field]: value
      }
    }));
  };

  // Function to handle select changes for patient data
  const handlePatientSelectChange = (field, value) => {
    console.log(`Updating patient.${field} to:`, value);
    
    // Special handling for gender based field
    if (field === 'title') {
      // If title is changed, update gender accordingly
      const gender = value === 'Mr' ? 'male' : value === 'Mrs' ? 'female' : file?.patient?.gender || '';
      
      setFile(prevFile => ({
        ...prevFile,
        patient: {
          ...prevFile.patient,
          [field]: value,
          gender: gender
        }
      }));
      return;
    }
    
    // Standard handling for other fields
    setFile(prevFile => ({
      ...prevFile,
      patient: {
        ...prevFile.patient,
        [field]: value
      }
    }));
  };

  // Handle member input changes - similar to handlePatientInputChange
  const handleMemberInputChange = (field, value) => {
    console.log(`Updating medical_cover.member.${field} to:`, value);
    
    // Special handling for ID number - extract and populate date of birth
    if (field === 'id' && value.length >= 6) {
      const idNumber = value;
      const yearPart = idNumber.substring(0, 2);
      const monthPart = idNumber.substring(2, 4);
      const dayPart = idNumber.substring(4, 6);
      
      // Determine the century
      const currentYear = new Date().getFullYear();
      const currentCentury = Math.floor(currentYear / 100);
      const currentYearLastTwo = currentYear % 100;
      
      // If the year part is greater than the current year's last two digits,
      // it's likely from the previous century
      const fullYear = parseInt(yearPart) > currentYearLastTwo
        ? `${currentCentury - 1}${yearPart}`
        : `${currentCentury}${yearPart}`;
      
      // Update date of birth fields
      setMemberDateOfBirth({
        year: fullYear,
        month: monthPart,
        day: dayPart
      });
      
      // Update the file state with the extracted DOB
      setFile(prevFile => ({
        ...prevFile,
        medical_cover: {
          ...prevFile.medical_cover,
          member: {
            ...prevFile.medical_cover?.member,
            [field]: value,
            dob: `${fullYear}/${monthPart}/${dayPart}`
          }
        }
      }));
      return;
    }
    
    // Special handling for name - auto-generate initials
    if (field === 'name' || field === 'surname') {
      setFile(prevFile => {
        const newName = field === 'name' ? value : prevFile.medical_cover?.member?.name || '';
        const newSurname = field === 'surname' ? value : prevFile.medical_cover?.member?.surname || '';
        
        // Generate initials from name and surname
        let initials = '';
        if (newName) {
          // Split by spaces in case there's a middle name
          const nameParts = newName.split(' ');
          nameParts.forEach(part => {
            if (part.trim()) {
              initials += part.charAt(0).toUpperCase() + '.';
            }
          });
        }
        
        if (newSurname) {
          initials += newSurname.charAt(0).toUpperCase() + '.';
        }
        
        return {
          ...prevFile,
          medical_cover: {
            ...prevFile.medical_cover,
            member: {
              ...prevFile.medical_cover?.member,
              [field]: value,
              initials: initials.trim()
            }
          }
        };
      });
      return;
    }
    
    // Standard handling for other fields
    setFile(prevFile => ({
      ...prevFile,
      medical_cover: {
        ...prevFile.medical_cover,
        member: {
          ...prevFile.medical_cover?.member,
          [field]: value
        }
      }
    }));
  };

  // Function to handle select changes for member data - similar to handlePatientSelectChange
  const handleMemberSelectChange = (field, value) => {
    console.log(`Updating medical_cover.member.${field} to:`, value);
    
    // Special handling for gender based field
    if (field === 'title') {
      // If title is changed, update gender accordingly
      const gender = value === 'Mr' ? 'male' : value === 'Mrs' ? 'female' : memberGender || '';
      setMemberGender(gender);
      
      setFile(prevFile => ({
        ...prevFile,
        medical_cover: {
          ...prevFile.medical_cover,
          member: {
            ...prevFile.medical_cover?.member,
            [field]: value,
            gender: gender
          }
        }
      }));
      return;
    }
    
    // Standard handling for other fields
    setFile(prevFile => ({
      ...prevFile,
      medical_cover: {
        ...prevFile.medical_cover,
        member: {
          ...prevFile.medical_cover?.member,
          [field]: value
        }
      }
    }));
  };

  // Function to handle medical scheme selection
  const handleMedicalSchemeChange = (schemeId) => {
    console.log('Selected medical scheme:', schemeId);
    
    setFile(prevFile => ({
      ...prevFile,
      medical_cover: {
        ...prevFile.medical_cover,
        medical_aid: {
          ...prevFile.medical_cover?.medical_aid,
          scheme_id: schemeId,
          name: medicalSchemes.find(scheme => scheme.uid === schemeId)?.scheme_name || ''
        }
      }
    }));
  };

  // Function to handle injury on duty input changes
  const handleInjuryInputChange = (field, value) => {
    console.log(`Updating medical_cover.injury_on_duty.${field} to:`, value);
    
    setFile(prevFile => ({
      ...prevFile,
      medical_cover: {
        ...prevFile.medical_cover,
        injury_on_duty: {
          ...prevFile.medical_cover?.injury_on_duty,
          [field]: value
        }
      }
    }));
  };

  // Get medical schemes from the file data response instead of a separate API call
  useEffect(() => {
    async function fetchFileData() {
      if (isNewRecord) {
        // Generate new file number and account number for new records
        const newFileNumber = `F${new Date().getFullYear()}${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;
        const newAccountNumber = `A${Math.floor(Math.random() * 1000000).toString().padStart(6, '0')}`;
        
        try {
          // Even for new records, fetch medical schemes
          const response = await fetch(`/api/files/new`);
          const data = await response.json();
          
          setFile({
            file_number: newFileNumber,
            account_number: newAccountNumber,
            patient: {
              name: '',
              gender: '',
            },
            medical_cover: data.medical_cover
          });
          
          // Set medical schemes from the response
          if (data.medical_schemes) {
            setMedicalSchemes(data.medical_schemes);
          }
          
        } catch (error) {
          console.error('Failed to fetch medical schemes for new record:', error);
          setFile({
            file_number: newFileNumber,
            account_number: newAccountNumber,
            patient: {
              name: '',
              gender: '',
            }
          });
        }
        
        setLoading(false);
        return;
      }

      try {
        const response = await fetch(`/api/files/${uid}`);
        const data = await response.json();
        setFile(data);
        
        // Set medical schemes from the response
        if (data.medical_schemes) {
          setMedicalSchemes(data.medical_schemes);
        }
        
      } catch (error) {
        console.error('Failed to fetch file data:', error);
      } finally {
        setLoading(false);
      }
    }

    fetchFileData();
  }, [uid, isNewRecord]);

  // Send header data to layout
  useEffect(() => {
    if (file) {
      const headerData = {
        fileNumber: file.file_number,
        accountNumber: file.account_number
      };
      
      // Dispatch a custom event with the header data
      window.dispatchEvent(new CustomEvent('file-header-data', { detail: headerData }));
    }
  }, [file]);

  // Function to save the file data
  const handleSave = async () => {
    if (!file) return;
    
    try {
      setSaving(true);
      console.log('Saving file data:', file);
      
      const endpoint = isNewRecord ? '/api/files/new' : `/api/files/${uid}`;
      const method = isNewRecord ? 'POST' : 'PUT';
      
      const response = await fetch(endpoint, {
        method,
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(file),
      });
      
      if (!response.ok) {
        throw new Error('Failed to save file data');
      }
      
      const savedData = await response.json();
      
      // Update the file state with the returned data
      setFile(savedData);
      
      // If this was a new record, redirect to the saved record's page
      if (isNewRecord && savedData.uid) {
        router.push(`/sites/file-data/${savedData.uid}`);
      }
      
      console.log('File saved successfully:', savedData);
      alert("File data saved successfully");
    } catch (error) {
      console.error('Error saving file:', error);
      alert("Failed to save file data");
    } finally {
      setSaving(false);
    }
  };

  // Listen for save trigger from layout
  useEffect(() => {
    const handleSaveTrigger = () => {
      handleSave();
    };
    
    window.addEventListener('file-save-triggered', handleSaveTrigger);
    
    return () => {
      window.removeEventListener('file-save-triggered', handleSaveTrigger);
    };
  }, [handleSave]);

  // Function to filter and sort notes
  const filterNotes = (notes) => {
    if (!notes) return [];
    
    // First filter by search query
    let filtered = notes;
    if (searchQuery) {
      filtered = filtered.filter(note => 
        note.notes?.toLowerCase().includes(searchQuery.toLowerCase())
      );
    }
    
    // Then filter by date range
    if (startDate) {
      filtered = filtered.filter(note => 
        new Date(note.time_stamp) >= startDate
      );
    }
    
    if (endDate) {
      filtered = filtered.filter(note => 
        new Date(note.time_stamp) <= endDate
      );
    }
    
    // Sort by timestamp
    filtered.sort((a, b) => {
      const dateA = new Date(a.time_stamp);
      const dateB = new Date(b.time_stamp);
      return sortOrder === 'desc' ? dateB - dateA : dateA - dateB;
    });
    
    return filtered;
  };
  
  // Toggle sort order
  const toggleSortOrder = () => {
    setSortOrder(prev => prev === 'desc' ? 'asc' : 'desc');
  };
  
  // Format date for display
  const formatDateTime = (dateString) => {
    const date = new Date(dateString);
    return format(date, 'yyyy/MM/dd HH:mm');
  };

  // Function to handle opening the note modal
  const openNoteModal = (tabType) => {
    setActiveNoteTab(tabType);
    setNoteDateTime(new Date());
    setNoteContent('');
    setUploadedFiles([]);
    setIsNoteModalOpen(true);
  };
  
  // Function to handle file uploads
  const handleFileUpload = (e) => {
    const files = Array.from(e.target.files);
    setUploadedFiles(prev => [...prev, ...files]);
  };
  
  // Function to remove a file from the upload list
  const removeFile = (index) => {
    setUploadedFiles(prev => prev.filter((_, i) => i !== index));
  };
  
  // Function to save the new note
  const saveNewNote = async () => {
    // Add a check for the file object
    if (!file) {
      console.error('Cannot save note: File data is not loaded yet.');
      alert('File data is not ready. Please try again.');
      return;
    }
    console.log(file);
    debugger;
    
    if (!noteContent.trim()) {
      alert('Please enter note content');
      return;
    }
    
    try {
      // Convert file objects to base64 for transmission
      const processedFiles = [];
      
      for (const file of uploadedFiles) {
        const reader = new FileReader();
        const filePromise = new Promise((resolve) => {
          reader.onload = (e) => {
            resolve({
              name: file.name,
              type: file.type,
              size: file.size,
              content: e.target.result
            });
          };
          reader.readAsDataURL(file);
        });
        
        processedFiles.push(await filePromise);
      }
      
      // Prepare the note data
      const noteData = {
        fileId: file.uid, // Now safe to access file.uid
        fileInfoPatientId: file.fileinfo_patient ? file.fileinfo_patient[0]?.uid : '',
        patientId: file.patient?.uid,
        orgId: file.orgid, 
        timeStamp: noteDateTime.toISOString(),
        notes: noteContent,
        tabType: activeNoteTab, // 'file' or 'clinical'
        files: processedFiles
      };
      
      // Save the note to the database
      const response = await fetch('/api/files/notes', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(noteData),
      });
      
      if (!response.ok) {
        throw new Error('Failed to save note');
      }
      
      const savedNote = await response.json();
      
      // Update the file state with the new note
      setFile(prevFile => {
        const updatedFile = { ...prevFile };
        
        // Initialize notes object if it doesn't exist
        if (!updatedFile.notes) {
          updatedFile.notes = {
            file_notes: [],
            clinical_notes: []
          };
        }
        
        // Add the new note to the appropriate array
        if (activeNoteTab === 'file') {
          updatedFile.notes.file_notes = [savedNote, ...(updatedFile.notes.file_notes || [])];
        } else if (activeNoteTab === 'clinical') {
          updatedFile.notes.clinical_notes = [savedNote, ...(updatedFile.notes.clinical_notes || [])];
        }
        
        return updatedFile;
      });
      
      // Close the modal
      setIsNoteModalOpen(false);
      
    } catch (error) {
      console.error('Error saving note:', error);
      alert('Failed to save note');
    }
  };

  const fileNotFound = !file && !isNewRecord;

  if (loading) {
    return <div>Loading...</div>;
  }

  return (
    <div className="h-full flex flex-col overflow-hidden">
      {/* Main content container - takes full height and prevents overflow */}
      <div className="flex flex-1 overflow-hidden">
        {/* Left Section - 50% width */}
        <div className="w-1/2 p-4 overflow-hidden">
          <Card className="h-full flex flex-col overflow-hidden">
            <Tabs defaultValue="tab1" className="h-full flex flex-col overflow-hidden">
              <TabsList className="grid w-full grid-cols-3 shrink-0">
                <TabsTrigger value="tab1">Patient Details</TabsTrigger>
                <TabsTrigger value="tab2">Medical History</TabsTrigger>
                <TabsTrigger value="tab3">Documents</TabsTrigger>
              </TabsList>
              {fileNotFound ? (
                <div className="flex-1 flex items-center justify-center p-6 text-gray-500">
                  File not found
                </div>
              ) : (
                <>
                  <TabsContent value="tab1" className="flex-1 overflow-hidden">
                    <div className="p-6 h-full overflow-auto">
                      <div className="grid grid-cols-2 gap-x-6 gap-y-4">
                        {/* Left Column - Row 1 */}
                        <div className="space-y-2">
                          <Label htmlFor="idNo">ID No</Label>
                          <Input 
                            id="idNo" 
                            placeholder="Enter ID number" 
                            value={file?.patient?.id || ''}
                            onChange={(e) => handlePatientInputChange('id', e.target.value)}
                          />
                        </div>
                        
                        {/* Right Column - Row 1 - CHANGED FROM INPUT TO SELECT */}
                        <div className="space-y-2">
                          <Label htmlFor="title">Title</Label>
                          <Select 
                            value={file?.patient?.title || ''} 
                            onValueChange={(value) => handlePatientSelectChange('title', value)}
                          >
                            <SelectTrigger>
                              <SelectValue placeholder="Select title" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="Mr">Mr</SelectItem>
                              <SelectItem value="Mrs">Mrs</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>

                        {/* Left Column - Row 2 */}
                        <div className="space-y-2">
                          <Label htmlFor="name">Name</Label>
                          <Input 
                            id="name" 
                            placeholder="Enter name" 
                            value={file?.patient?.name || ''}
                            onChange={(e) => handlePatientInputChange('name', e.target.value)}
                          />
                        </div>

                        {/* Right Column - Row 2 */}
                        <div className="space-y-2">
                          <Label htmlFor="initials">Initials</Label>
                          <Input 
                            id="initials" 
                            placeholder="Auto-generated from name" 
                            value={file?.patient?.initials || ''}
                            onChange={(e) => handlePatientInputChange('initials', e.target.value)}
                            readOnly
                          />
                        </div>

                        {/* Left Column - Row 3 */}
                        <div className="space-y-2">
                          <Label htmlFor="surname">Surname</Label>
                          <Input 
                            id="surname" 
                            placeholder="Enter surname" 
                            value={file?.patient?.surname || ''}
                            onChange={(e) => handlePatientInputChange('surname', e.target.value)}
                          />
                        </div>

                        {/* Right Column - Row 3 (Date of Birth) */}
                        <div className="space-y-2">
                          <Label htmlFor="dob-year">Date of Birth</Label>
                          <div className="flex items-center">
                            <div className="flex-1">
                              <Input
                                id="dob-year"
                                ref={yearInputRef}
                                placeholder="YYYY"
                                maxLength={4}
                                className="text-center"
                                value={dateOfBirth.year}
                                onChange={(e) => handleDatePartChange('year', e.target.value, 4, monthInputRef)}
                              />
                            </div>
                            <span className="px-2 text-gray-500">/</span>
                            <div className="w-16">
                              <Input
                                id="dob-month"
                                ref={monthInputRef}
                                placeholder="MM"
                                maxLength={2}
                                className="text-center"
                                value={dateOfBirth.month}
                                onChange={(e) => handleDatePartChange('month', e.target.value, 2, dayInputRef)}
                              />
                            </div>
                            <span className="px-2 text-gray-500">/</span>
                            <div className="w-16">
                              <Input
                                id="dob-day"
                                ref={dayInputRef}
                                placeholder="DD"
                                maxLength={2}
                                className="text-center"
                                value={dateOfBirth.day}
                                onChange={(e) => handleDatePartChange('day', e.target.value, 2)}
                              />
                            </div>
                          </div>
                        </div>

                        {/* Left Column - Row 4 */}
                        <div className="space-y-2">
                          <Label htmlFor="gender">Gender</Label>
                          <Select 
                            value={file?.patient?.gender || ''} 
                            onValueChange={(value) => handlePatientSelectChange('gender', value)}
                          >
                            <SelectTrigger>
                              <SelectValue placeholder="Select gender" />
                            </SelectTrigger>
                            <SelectContent>
                              <SelectItem value="male">Male</SelectItem>
                              <SelectItem value="female">Female</SelectItem>
                            </SelectContent>
                          </Select>
                        </div>

                        {/* Right Column - Row 4 */}
                        <div className="space-y-2">
                          <Label htmlFor="cellphone">Cellphone</Label>
                          <Input 
                            id="cellphone" 
                            placeholder="Enter cellphone number" 
                            value={file?.patient?.cell_phone || ''}
                            onChange={(e) => handlePatientInputChange('cell_phone', e.target.value)}
                          />
                        </div>

                        {/* Left Column - Row 5 */}
                        <div className="space-y-2">
                          <Label htmlFor="additionalContact1">Additional Contact Name</Label>
                          <Input 
                            id="additionalContact1" 
                            placeholder="Enter contact name" 
                            value={file?.patient?.additional_name || ''}
                            onChange={(e) => handlePatientInputChange('additional_name', e.target.value)}
                          />
                        </div>

                        {/* Right Column - Row 5 */}
                        <div className="space-y-2">
                          <Label htmlFor="additionalContact2">Additional Contact Cell</Label>
                          <Input 
                            id="additionalContact2" 
                            placeholder="Enter contact cell" 
                            value={file?.patient?.additional_cell || ''}
                            onChange={(e) => handlePatientInputChange('additional_cell', e.target.value)}
                          />
                        </div>

                        {/* Left Column - Row 6 */}
                        <div className="space-y-2 col-span-2">
                          <Label htmlFor="email">Email Address</Label>
                          <Input 
                            id="email" 
                            type="email" 
                            placeholder="Enter email address" 
                            value={file?.patient?.email || ''}
                            onChange={(e) => handlePatientInputChange('email', e.target.value)}
                          />
                        </div>

                        {/* Full Width - Row 7 */}
                        <div className="space-y-2 col-span-2">
                          <Label htmlFor="address">Residential Address</Label>
                          <Input 
                            id="address" 
                            placeholder="Enter residential address" 
                            value={file?.patient?.address || ''}
                            onChange={(e) => handlePatientInputChange('address', e.target.value)}
                          />
                        </div>
                      </div>
                    </div>
                  </TabsContent>
                  <TabsContent value="tab2" className="flex-1 overflow-auto">
                    <div className="p-6 h-full overflow-auto space-y-6">
                      <div>
                        <h3 className="text-lg font-medium mb-4">Medical Cover</h3>
                        
                        {/* Radio Group for Cover Type */}
                        <RadioGroup 
                          value={coverType} 
                          onValueChange={handleCoverTypeChange}
                          className="flex space-x-4 mb-6"
                        >
                          <div className="flex items-center space-x-2">
                            <RadioGroupItem value="medical-aid" id="medical-aid" />
                            <Label htmlFor="medical-aid">Medical Aid</Label>
                          </div>
                          <div className="flex items-center space-x-2">
                            <RadioGroupItem value="private" id="private" />
                            <Label htmlFor="private">Private</Label>
                          </div>
                          <div className="flex items-center space-x-2">
                            <RadioGroupItem value="injury-on-duty" id="injury-on-duty" />
                            <Label htmlFor="injury-on-duty">Injury on Duty</Label>
                          </div>
                        </RadioGroup>
                        
                        {/* Dynamic content based on selected cover type */}
                        {coverType === 'medical-aid' && (
                          <div className="space-y-6">
                            <h4 className="text-md font-medium">Medical Aid Details</h4>
                            <div className="space-y-4">
                              <div className="space-y-2">
                                <Label htmlFor="medical-aid-name">Medical Aid</Label>
                                <Select 
                                  value={file?.medical_cover?.medical_aid?.scheme_id || ''}
                                  onValueChange={handleMedicalSchemeChange}
                                >
                                  <SelectTrigger>
                                    <SelectValue placeholder="Select medical aid" />
                                  </SelectTrigger>
                                  <SelectContent>
                                    {medicalSchemes.map(scheme => (
                                      <SelectItem key={scheme.uid} value={scheme.uid}>
                                        {scheme.scheme_name}
                                      </SelectItem>
                                    ))}
                                  </SelectContent>
                                </Select>
                              </div>
                              
                              <div className="space-y-2">
                                <Label htmlFor="membership-number">Membership Number</Label>
                                <Input 
                                  id="membership-number" 
                                  placeholder="Enter membership number" 
                                  value={file?.medical_cover?.medical_aid?.membership_number || ''}
                                  onChange={(e) => {
                                    setFile(prevFile => ({
                                      ...prevFile,
                                      medical_cover: {
                                        ...prevFile.medical_cover,
                                        medical_aid: {
                                          ...prevFile.medical_cover?.medical_aid,
                                          membership_number: e.target.value
                                        }
                                      }
                                    }));
                                  }}
                                />
                              </div>
                              
                              <div className="space-y-2">
                                <Label htmlFor="dependent-code">Patient Dependent Code</Label>
                                <Input 
                                  id="dependent-code" 
                                  placeholder="Enter dependent code" 
                                  value={file?.medical_cover?.medical_aid?.dependent_code || ''}
                                  onChange={(e) => {
                                    setFile(prevFile => ({
                                      ...prevFile,
                                      medical_cover: {
                                        ...prevFile.medical_cover,
                                        medical_aid: {
                                          ...prevFile.medical_cover?.medical_aid,
                                          dependent_code: e.target.value
                                        }
                                      }
                                    }));
                                  }}
                                />
                              </div>
                            </div>
                            
                            <div className="pt-4 border-t">
                              <h4 className="text-md font-medium mb-4">Main Member</h4>
                              
                              <div className="flex items-center space-x-2 mb-4">
                                <Checkbox 
                                  id="same-as-patient" 
                                  checked={sameAsPatient}
                                  onCheckedChange={handleSameAsPatientChange}
                                />
                                <Label htmlFor="same-as-patient">Same as patient</Label>
                              </div>
                              
                              {!sameAsPatient && (
                                <div className="space-y-4">
                                  <div className="space-y-2">
                                    <Label htmlFor="member-id">ID Number</Label>
                                    <Input 
                                      id="member-id" 
                                      placeholder="Enter ID number" 
                                      value={file?.medical_cover?.member?.id || ''}
                                      onChange={(e) => handleMemberInputChange('id', e.target.value)}
                                    />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-title">Title</Label>
                                    <Select 
                                      value={file?.medical_cover?.member?.title || ''} 
                                      onValueChange={(value) => handleMemberSelectChange('title', value)}
                                    >
                                      <SelectTrigger>
                                        <SelectValue placeholder="Select title" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        <SelectItem value="Mr">Mr</SelectItem>
                                        <SelectItem value="Mrs">Mrs</SelectItem>
                                      </SelectContent>
                                    </Select>
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-name">Name</Label>
                                    <Input 
                                      id="member-name" 
                                      placeholder="Enter name" 
                                      value={file?.medical_cover?.member?.name || ''}
                                      onChange={(e) => handleMemberInputChange('name', e.target.value)}
                                    />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-initials">Initials</Label>
                                    <Input 
                                      id="member-initials" 
                                      placeholder="Auto-generated from name" 
                                      value={file?.medical_cover?.member?.initials || ''}
                                      readOnly
                                    />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-surname">Surname</Label>
                                    <Input 
                                      id="member-surname" 
                                      placeholder="Enter surname" 
                                      value={file?.medical_cover?.member?.surname || ''}
                                      onChange={(e) => handleMemberInputChange('surname', e.target.value)}
                                    />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-dob-year">Date of Birth</Label>
                                    <div className="flex items-center">
                                      <div className="flex-1">
                                        <Input
                                          id="member-dob-year"
                                          ref={memberYearInputRef}
                                          placeholder="YYYY"
                                          maxLength={4}
                                          className="text-center"
                                          value={memberDateOfBirth.year}
                                          onChange={(e) => handleMemberDatePartChange('year', e.target.value, 4, memberMonthInputRef)}
                                        />
                                      </div>
                                      <span className="px-2 text-gray-500">/</span>
                                      <div className="w-16">
                                        <Input
                                          id="member-dob-month"
                                          ref={memberMonthInputRef}
                                          placeholder="MM"
                                          maxLength={2}
                                          className="text-center"
                                          value={memberDateOfBirth.month}
                                          onChange={(e) => handleMemberDatePartChange('month', e.target.value, 2, memberDayInputRef)}
                                        />
                                      </div>
                                      <span className="px-2 text-gray-500">/</span>
                                      <div className="w-16">
                                        <Input
                                          id="member-dob-day"
                                          ref={memberDayInputRef}
                                          placeholder="DD"
                                          maxLength={2}
                                          className="text-center"
                                          value={memberDateOfBirth.day}
                                          onChange={(e) => handleMemberDatePartChange('day', e.target.value, 2)}
                                        />
                                      </div>
                                    </div>
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-gender">Gender</Label>
                                    <Select 
                                      value={file?.medical_cover?.member?.gender || ''} 
                                      onValueChange={(value) => handleMemberSelectChange('gender', value)}
                                    >
                                      <SelectTrigger>
                                        <SelectValue placeholder="Select gender" />
                                      </SelectTrigger>
                                      <SelectContent>
                                        <SelectItem value="male">Male</SelectItem>
                                        <SelectItem value="female">Female</SelectItem>
                                      </SelectContent>
                                    </Select>
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-cell">Cell Number</Label>
                                    <Input 
                                      id="member-cell" 
                                      placeholder="Enter cell number" 
                                      value={file?.medical_cover?.member?.cell || ''}
                                      onChange={(e) => handleMemberInputChange('cell', e.target.value)}
                                    />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-contact-name">Additional Contact Name</Label>
                                    <Input id="member-contact-name" placeholder="Enter contact name" />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-contact-number">Additional Contact Number</Label>
                                    <Input id="member-contact-number" placeholder="Enter contact number" />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-email">Email Address</Label>
                                    <Input id="member-email" type="email" placeholder="Enter email address" />
                                  </div>
                                  
                                  <div className="space-y-2">
                                    <Label htmlFor="member-address">Residential Address</Label>
                                    <Input id="member-address" placeholder="Enter residential address" />
                                  </div>
                                </div>
                              )}
                            </div>
                          </div>
                        )}
                        
                        {coverType === 'private' && (
                          <div className="p-6 flex items-center justify-center text-gray-500">
                            <p>No additional information needed for private payment.</p>
                          </div>
                        )}
                        
                        {coverType === 'injury-on-duty' && (
                          <div className="space-y-4">
                            <div className="space-y-2">
                              <Label htmlFor="company-name">Name of Company</Label>
                              <Input 
                                id="company-name" 
                                placeholder="Enter company name"
                                value={file?.medical_cover?.injury_on_duty?.company_name || ''}
                                onChange={(e) => handleInjuryInputChange('company_name', e.target.value)}
                              />
                            </div>
                            
                            <div className="space-y-2">
                              <Label htmlFor="contact-person">Contact Person</Label>
                              <Input 
                                id="contact-person" 
                                placeholder="Enter contact person name"
                                value={file?.medical_cover?.injury_on_duty?.contact_person || ''}
                                onChange={(e) => handleInjuryInputChange('contact_person', e.target.value)}
                              />
                            </div>
                            
                            <div className="space-y-2">
                              <Label htmlFor="contact-number">Contact Number</Label>
                              <Input 
                                id="contact-number" 
                                placeholder="Enter contact number"
                                value={file?.medical_cover?.injury_on_duty?.contact_number || ''}
                                onChange={(e) => handleInjuryInputChange('contact_number', e.target.value)}
                              />
                            </div>
                            
                            <div className="space-y-2">
                              <Label htmlFor="contact-email">Contact Email</Label>
                              <Input 
                                id="contact-email" 
                                type="email" 
                                placeholder="Enter contact email"
                                value={file?.medical_cover?.injury_on_duty?.contact_email || ''}
                                onChange={(e) => handleInjuryInputChange('contact_email', e.target.value)}
                              />
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                  </TabsContent>
                  <TabsContent value="tab3" className="flex-1 overflow-auto">
                    <div className="p-4 h-full overflow-auto">
                      <h3 className="text-lg font-medium">Extra Information</h3>
                      <div className="mt-4">
                        <Editor 
                          content={extraInfo}
                          onChange={(content) => setExtraInfo(content)}
                        />
                      </div>
                    </div>
                  </TabsContent>
                </>
              )}
            </Tabs>
          </Card>
        </div>

        {/* Right Section - 50% width */}
        <div className="w-1/2 p-4 overflow-hidden">
          <Card className="h-full flex flex-col overflow-hidden">
            <Tabs defaultValue="tab1" className="h-full flex flex-col overflow-hidden">
              <TabsList className="grid w-full grid-cols-4 shrink-0">
                <TabsTrigger value="tab1">File Notes</TabsTrigger>
                <TabsTrigger value="tab2">Clinical Notes</TabsTrigger>
                <TabsTrigger value="tab3">eScripts</TabsTrigger>
                <TabsTrigger value="tab4">Payments and Other</TabsTrigger>
              </TabsList>
              {fileNotFound ? (
                <div className="flex-1 flex items-center justify-center p-6 text-gray-500">
                  File not found
                </div>
              ) : (
                <>
                  {/* File Notes Tab */}
                  <TabsContent value="tab1" className="flex-1 overflow-hidden">
                    <div className="h-full flex flex-col">
                      {/* Header section - 20% height */}
                      <div className="h-[20%] p-4 border-b space-y-3">
                        <div className="flex justify-between items-center">
                          <h3 className="text-lg font-medium">File Notes</h3>
                          <Button 
                            size="sm" 
                            className="bg-primary hover:bg-primary/90"
                            onClick={() => openNoteModal('file')}
                          >
                            <Plus className="mr-2 h-4 w-4" /> Add New Note
                          </Button>
                        </div>
                        
                        <div className="relative">
                          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                          <Input
                            placeholder="Search in notes..."
                            className="pl-8"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                          />
                        </div>
                        
                        <div className="flex gap-2 items-center">
                          <div className="flex-1 flex gap-2">
                            <Popover>
                              <PopoverTrigger asChild>
                                <Button
                                  variant="outline"
                                  className="w-full justify-start text-left font-normal"
                                >
                                  <CalendarIcon className="mr-2 h-4 w-4" />
                                  {startDate ? format(startDate, "yyyy/MM/dd") : "From"}
                                </Button>
                              </PopoverTrigger>
                              <PopoverContent className="w-auto p-0">
                                <Calendar
                                  mode="single"
                                  selected={startDate}
                                  onSelect={setStartDate}
                                  initialFocus
                                />
                              </PopoverContent>
                            </Popover>
                            
                            <Popover>
                              <PopoverTrigger asChild>
                                <Button
                                  variant="outline"
                                  className="w-full justify-start text-left font-normal"
                                >
                                  <CalendarIcon className="mr-2 h-4 w-4" />
                                  {endDate ? format(endDate, "yyyy/MM/dd") : "To"}
                                </Button>
                              </PopoverTrigger>
                              <PopoverContent className="w-auto p-0">
                                <Calendar
                                  mode="single"
                                  selected={endDate}
                                  onSelect={setEndDate}
                                  initialFocus
                                />
                              </PopoverContent>
                            </Popover>
                          </div>
                          
                          <Button 
                            variant="outline" 
                            size="icon" 
                            onClick={toggleSortOrder}
                            title={sortOrder === 'desc' ? 'Newest first' : 'Oldest first'}
                          >
                            <ArrowUpDown className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                      
                      {/* Timeline section - 80% height */}
                      <div className="h-[80%] overflow-auto p-4">
                        {file?.notes?.file_notes && filterNotes(file.notes.file_notes).length > 0 ? (
                          <div className="space-y-6">
                            {filterNotes(file.notes.file_notes).map((note) => (
                              <div key={note.uid} className="border rounded-md p-4 bg-white shadow-sm">
                                <div className="flex justify-between items-start mb-2">
                                  <h3 className="text-lg font-bold text-primary">
                                    {formatDateTime(note.time_stamp)}
                                  </h3>
                                </div>
                                <div className="ml-4 mt-2 text-gray-700">
                                  <p>{note.notes}</p>
                                </div>
                                {note.files && note.files.length > 0 && (
                                  <div className="mt-4 ml-4">
                                    <div className="flex flex-wrap gap-2">
                                      {note.files.map((file) => (
                                        <div 
                                          key={file.uid} 
                                          className="flex items-center p-2 border rounded bg-gray-50 hover:bg-gray-100 transition-colors text-sm"
                                        >
                                          <a href={file.file_location} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">
                                            {file.file_name}
                                          </a>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        ) : (
                          <div className="flex justify-center items-center h-full text-gray-500">
                            {searchQuery || startDate || endDate 
                              ? "No matching file notes found" 
                              : "No file notes available"}
                          </div>
                        )}
                      </div>
                    </div>
                  </TabsContent>
                  
                  {/* Clinical Notes Tab */}
                  <TabsContent value="tab2" className="flex-1 overflow-hidden">
                    <div className="h-full flex flex-col">
                      {/* Header section - 20% height */}
                      <div className="h-[20%] p-4 border-b space-y-3">
                        <div className="flex justify-between items-center">
                          <h3 className="text-lg font-medium">Clinical Notes</h3>
                          <Button 
                            size="sm" 
                            className="bg-primary hover:bg-primary/90"
                            onClick={() => openNoteModal('clinical')}
                          >
                            <Plus className="mr-2 h-4 w-4" /> Add New Note
                          </Button>
                        </div>
                        
                        <div className="relative">
                          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                          <Input
                            placeholder="Search in notes..."
                            className="pl-8"
                            value={searchQuery}
                            onChange={(e) => setSearchQuery(e.target.value)}
                          />
                        </div>
                        
                        <div className="flex gap-2 items-center">
                          <div className="flex-1 flex gap-2">
                            <Popover>
                              <PopoverTrigger asChild>
                                <Button
                                  variant="outline"
                                  className="w-full justify-start text-left font-normal"
                                >
                                  <CalendarIcon className="mr-2 h-4 w-4" />
                                  {startDate ? format(startDate, "yyyy/MM/dd") : "From"}
                                </Button>
                              </PopoverTrigger>
                              <PopoverContent className="w-auto p-0">
                                <Calendar
                                  mode="single"
                                  selected={startDate}
                                  onSelect={setStartDate}
                                  initialFocus
                                />
                              </PopoverContent>
                            </Popover>
                            
                            <Popover>
                              <PopoverTrigger asChild>
                                <Button
                                  variant="outline"
                                  className="w-full justify-start text-left font-normal"
                                >
                                  <CalendarIcon className="mr-2 h-4 w-4" />
                                  {endDate ? format(endDate, "yyyy/MM/dd") : "To"}
                                </Button>
                              </PopoverTrigger>
                              <PopoverContent className="w-auto p-0">
                                <Calendar
                                  mode="single"
                                  selected={endDate}
                                  onSelect={setEndDate}
                                  initialFocus
                                />
                              </PopoverContent>
                            </Popover>
                          </div>
                          
                          <Button 
                            variant="outline" 
                            size="icon" 
                            onClick={toggleSortOrder}
                            title={sortOrder === 'desc' ? 'Newest first' : 'Oldest first'}
                          >
                            <ArrowUpDown className="h-4 w-4" />
                          </Button>
                        </div>
                      </div>
                      
                      {/* Timeline section - 80% height */}
                      <div className="h-[80%] overflow-auto p-4">
                        {file?.notes?.clinical_notes && filterNotes(file.notes.clinical_notes).length > 0 ? (
                          <div className="space-y-6">
                            {filterNotes(file.notes.clinical_notes).map((note) => (
                              <div key={note.uid} className="border rounded-md p-4 bg-white shadow-sm">
                                <div className="flex justify-between items-start mb-2">
                                  <h3 className="text-lg font-bold text-primary">
                                    {formatDateTime(note.time_stamp)}
                                  </h3>
                                </div>
                                <div className="ml-4 mt-2 text-gray-700">
                                  <p>{note.notes}</p>
                                </div>
                                {note.files && note.files.length > 0 && (
                                  <div className="mt-4 ml-4">
                                    <div className="flex flex-wrap gap-2">
                                      {note.files.map((file) => (
                                        <div 
                                          key={file.uid} 
                                          className="flex items-center p-2 border rounded bg-gray-50 hover:bg-gray-100 transition-colors text-sm"
                                        >
                                          <a href={file.file_location} target="_blank" rel="noopener noreferrer" className="text-blue-600 hover:underline">
                                            {file.file_name}
                                          </a>
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                )}
                              </div>
                            ))}
                          </div>
                        ) : (
                          <div className="flex justify-center items-center h-full text-gray-500">
                            {searchQuery || startDate || endDate 
                              ? "No matching clinical notes found" 
                              : "No clinical notes available"}
                          </div>
                        )}
                      </div>
                    </div>
                  </TabsContent>
                  
                  {/* Other tabs */}
                  <TabsContent value="tab3" className="flex-1 overflow-auto">
                    <div className="p-4 h-full">eScripts Content</div>
                  </TabsContent>
                  <TabsContent value="tab4" className="flex-1 overflow-auto">
                    <div className="p-4 h-full">Payments and Other Content</div>
                  </TabsContent>
                </>
              )}
            </Tabs>
          </Card>
        </div>
      </div>

      {/* Add Note Modal */}
      {!fileNotFound && (
        <Dialog open={isNoteModalOpen} onOpenChange={setIsNoteModalOpen}>
          <DialogContent className="sm:max-w-[700px]">
            <DialogHeader>
              <DialogTitle>
                Add New {activeNoteTab === 'file' ? 'File' : 'Clinical'} Note
              </DialogTitle>
            </DialogHeader>
            
            <div className="grid gap-4 py-4">
              {/* Date time picker */}
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="note-date" className="text-right">
                  Date & Time
                </Label>
                <div className="col-span-3">
                  <div className="flex items-center gap-2">
                    <Popover>
                      <PopoverTrigger asChild>
                        <Button
                          variant="outline"
                          className="w-full justify-start text-left"
                        >
                          <CalendarIcon className="mr-2 h-4 w-4" />
                          {format(noteDateTime, "yyyy/MM/dd")}
                        </Button>
                      </PopoverTrigger>
                      <PopoverContent className="w-auto p-0">
                        <Calendar
                          mode="single"
                          selected={noteDateTime}
                          onSelect={(date) => setNoteDateTime(new Date(date))}
                          initialFocus
                        />
                      </PopoverContent>
                    </Popover>
                    
                    <Input 
                      type="time" 
                      defaultValue={format(noteDateTime, "HH:mm")}
                      className="w-32"
                      onChange={(e) => {
                        const [hours, minutes] = e.target.value.split(':');
                        const newDate = new Date(noteDateTime);
                        newDate.setHours(parseInt(hours));
                        newDate.setMinutes(parseInt(minutes));
                        setNoteDateTime(newDate);
                      }}
                    />
                  </div>
                </div>
              </div>
              
              {/* Note content */}
              <div className="grid grid-cols-4 items-start gap-4">
                <Label htmlFor="note-content" className="text-right">
                  Note
                </Label>
                <div className="col-span-3">
                  <Textarea
                    id="note-content"
                    value={noteContent}
                    onChange={(e) => setNoteContent(e.target.value)}
                    placeholder="Enter note details..."
                    className="min-h-[200px]"
                  />
                </div>
              </div>
              
              {/* Document upload */}
              <div className="grid grid-cols-4 items-start gap-4">
                <Label className="text-right">
                  Attachments
                </Label>
                <div className="col-span-3 space-y-3">
                  <div className="flex items-center gap-2">
                    <Button 
                      type="button" 
                      variant="outline"
                      onClick={() => fileInputRef.current?.click()}
                    >
                      <Upload className="mr-2 h-4 w-4" />
                      Upload Document
                    </Button>
                    <input
                      type="file"
                      ref={fileInputRef}
                      multiple
                      className="hidden"
                      onChange={handleFileUpload}
                    />
                    <span className="text-sm text-gray-500">
                      Upload any document
                    </span>
                  </div>
                  
                  {/* Display uploaded files */}
                  {uploadedFiles.length > 0 && (
                    <div className="space-y-2">
                      {uploadedFiles.map((file, index) => (
                        <div key={index} className="flex items-center justify-between p-2 bg-gray-50 rounded">
                          <span className="text-sm truncate">{file.name}</span>
                          <Button 
                            type="button" 
                            variant="ghost" 
                            size="sm"
                            onClick={() => removeFile(index)}
                          >
                            <X className="h-4 w-4" />
                          </Button>
                        </div>
                      ))}
                    </div>
                  )}
                </div>
              </div>
            </div>
            
            <DialogFooter>
              <Button 
                variant="outline" 
                onClick={() => setIsNoteModalOpen(false)}
              >
                Cancel
              </Button>
              <Button 
                onClick={saveNewNote}
                disabled={!noteContent.trim()}
              >
                Save Note
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
}
</file>

<file path="app/layout.tsx">
import { Toaster } from 'sonner'
import "./globals.css"
import { AuthProvider } from "@/app/components/providers/AuthProvider"

export const metadata = {
  title: "DigiFile",
  description: "",
}

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body suppressHydrationWarning className="antialiased overflow-hidden">
        <AuthProvider>
          <div className="flex h-screen overflow-hidden">
            <main className="flex-1">
              {children}
            </main>
          </div>
          <Toaster position="top-center" />
        </AuthProvider>
      </body>
    </html>
  )
}
</file>

<file path="Helperfiles/.cursorrules">
You are a Senior Front-End Developer and an Expert in ReactJS, NextJS, JavaScript, TypeScript, HTML, CSS and modern UI/UX frameworks (e.g., TailwindCSS, Shadcn, Radix). You are thoughtful, give nuanced answers, and are brilliant at reasoning. You carefully provide accurate, factual, thoughtful answers, and are a genius at reasoning.

- Follow the user’s requirements carefully & to the letter.
- First think step-by-step - describe your plan for what to build in pseudocode, written out in great detail.
- Confirm, then write code!
- Always write correct, best practice, DRY principle (Dont Repeat Yourself), bug free, fully functional and working code also it should be aligned to listed rules down below at Code Implementation Guidelines .
- Focus on easy and readability code, over being performant.
- Fully implement all requested functionality.
- Leave NO todo’s, placeholders or missing pieces.
- Ensure code is complete! Verify thoroughly finalised.
- Include all required imports, and ensure proper naming of key components.
- Be concise Minimize any other prose.
- If you think there might not be a correct answer, you say so.
- If you do not know the answer, say so, instead of guessing.

### Coding Environment
The user asks questions about the following coding languages:
- ReactJS
- NextJS 15
- JavaScript
- TypeScript
- TailwindCSS
- HTML
- CSS


### Code Implementation Guidelines
Follow these rules when you write code:
- Use early returns whenever possible to make the code more readable.
- Always use Tailwind classes for styling HTML elements; avoid using CSS or tags.
- Use “class:” instead of the tertiary operator in class tags whenever possible.
- Use descriptive variable and function/const names. Also, event functions should be named with a “handle” prefix, like “handleClick” for onClick and “handleKeyDown” for onKeyDown.
- Implement accessibility features on elements. For example, a tag should have a tabindex=“0”, aria-label, on:click, and on:keydown, and similar attributes.
- Use consts instead of functions, for example, “const toggle = () =>”. Also, define a type if possible.

## Organization Data Separation Rule
When working with multi-tenant databases:
1. Every database query MUST include the orgid filter in the WHERE clause
2. Store ORGANIZATION_ID in environment variables
3. Use AND conditions to combine orgid with other filters
4. Apply this rule to all API routes and database operations
5. Never expose organization data across tenants


<PROJECT STRUCTURE>
project/
├── app/
│   ├── actions/                 # Server-side code (internal only)
│   │   ├── auth.ts             # Re-exports of auth utilities
│   │   └── *.ts                # Other server actions
│   ├── api/                    # Server-side code (external connections)
│   │   ├── auth/               # Auth API routes
│   │   │   └── [...nextauth]/  # NextAuth.js route handlers
│   │   │       └── route.ts    # Auth API endpoint
│   │   └── */route.ts         # Other API routes
│   ├── components/
│   │   ├── providers/         # React context providers
│   │   │   ├── AuthProvider.tsx  # Auth context provider
│   │   │   └── *.tsx         # Other providers
│   │   ├── ui/               # Reusable UI components
│   │   │   └── *.tsx        # UI components
│   │   └── *.tsx            # Other components
│   ├── hooks/                # Custom React hooks
│   │   ├── use-session.ts   # Session management hook
│   │   └── *.ts             # Other custom hooks
│   ├── lib/                  # Server components for actions & api
│   │   ├── auth.ts          # Central auth configuration
│   │   ├── prisma.ts        # Prisma client
│   │   ├── utils.ts         # Utility functions
│   │   └── *.ts             # Other server utilities
│   ├── login/               # Authentication frontend
│   │   ├── signin/          # Sign in related pages
│   │   │   └── page.tsx     # Sign in page
│   │   ├── registration/    # Registration related pages
│   │   │   └── page.tsx     # Registration page
│   │   └── *.tsx            # Other login related pages
│   ├── sites/               # Main application frontend
│   │   ├── layout.tsx       # Sites layout
│   │   ├── file-data/      # File data management
│   │   │   └── page.tsx    # File data page
│   │   ├── settings/       # Settings pages
│   │   │   └── page.tsx    # Settings page
│   │   └── */page.tsx      # Other site pages
│   ├── types/              # Shared TypeScript interfaces
│   │   ├── next-auth.d.ts # Auth type definitions
│   │   └── *.d.ts         # Other type definitions
│   └── utils/             # Client-side utility functions
│       └── *.ts           # Utility files
├── helperfiles/          # AI rules and context
│   ├── .cursorrules     # AI coding guidelines
│   ├── .database_rules  # Database rules
│   └── *.rules          # Other rule files
├── middleware.ts        # Auth middleware
├── next.config.js      # Next.js configuration
├── tailwind.config.ts  # Tailwind configuration
├── components.json     # UI component configuration
└── prisma/
    ├── migrations/     # Database migration files
    │   └── *.sql      # Migration files
    └── schema.prisma  # Database schema
</PROJECT STRUCTURE>








<Auth>

The session will contain the organization ID and user role, which you can access in any protected route using the auth() function:
``` javascript
import { auth } from "@/auth"

export default async function ProtectedPage() {
  const session = await auth()
  // Access session.user.orgId and session.user.role
}
```


</Auth>

Session Structure>
The auth() function returns a session object with the following structure:

Session {
  user: {
    // Basic user info
    name: string | null       // Full name (firstName + surname)
    email: string | null      // User's email address
    
    // Organization info
    orgId: string            // UUID of user's organization
    
    // Role information
    roles: [                 // Array of user roles
      {
        role: {
          uid: string        // Role ID
          name: string       // Role name (e.g., "admin", "organizer")
        }
      }
    ]
  }
  expires: string            // ISO date string when session expires
}

Common role names:
- "admin" - Full system access
- "organizer" - Organization management access

Usage examples:
1. Check if user is admin:
   session?.user?.roles?.some(r => r.role.name === "admin")

2. Get organization ID:
   session?.user?.orgId

3. Get user's full name:
   session?.user?.name

Note: All session data is automatically filtered by organization ID (orgId) 
to maintain multi-tenant data separation.
</Session Structure>


<SupaBase Bucket>
Supabase Buckets are used for storing signatures, Logos and Documents.

Logos - /{orgid}/logo/
Signatures - /{orgid}/signatures/
Consent Forms - /{orgid}/consent-forms/
Documents - /{orgid}/documents/

We are using Bucket "DigiFile_Public" for storing all Documents. As seen above, the paths for the documents.

</SupaBase Bucket>
</file>

<file path="app/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight, RefreshCcw } from 'lucide-react'
import {
  add,
  eachDayOfInterval,
  endOfMonth,
  endOfWeek,
  format,
  getDay,
  isEqual,
  isSameDay,
  isSameMonth,
  isToday,
  startOfDay,
  startOfMonth,
  startOfToday,
  startOfWeek,
} from "date-fns"
import { Account, CalendarEvent, ViewType } from "@/app/types/calendar"
import { Button } from "@/app/components/ui/button"
import { AccountSelector } from "./account-selector/account-selector"
import { cn } from "@/app/lib/utils"
import { AppointmentModal } from "@/app/components/ui/appointment/appointment-modal"
import { useState } from "react"
import { formatTimeToLocal } from "@/app/lib/utils";

interface CalendarProps {
  accounts: Account[]
  events: CalendarEvent[]
  refreshData: () => void
  hasAdminAccess: boolean
  defaultSelectedAccount?: string
  selectedAccounts: string[]
  onToggleAccount: (accountId: string) => void
}

interface EventDisplayProps {
  event: CalendarEvent
  className?: string
  accounts: Account[]
  refreshData: () => void
  style?: React.CSSProperties
}

const EventDisplay = ({ event, className, accounts, refreshData, style }: EventDisplayProps) => {
  const [showModal, setShowModal] = useState(false)
  const eventStart = new Date(event.start)
  const eventEnd = new Date(event.end)
  
  // Calculate duration in hours for proper sizing
  const durationHours = (eventEnd.getTime() - eventStart.getTime()) / (1000 * 60 * 60)
  const startHour = eventStart.getHours() + (eventStart.getMinutes() / 60)
  
  const eventStyle = {
    ...style,
    top: `${startHour * 48}px`, // 48px is the height of each hour slot
    height: `${durationHours * 48}px`,
    position: 'absolute',
    width: '95%',
    zIndex: 10
  }

  return (
    <>
      <div
        className={cn(
          `${event.color}`,
          "px-2 rounded-md truncate",
          "text-xs font-medium text-white",
          "hover:opacity-90 cursor-pointer",
          className
        )}
        style={eventStyle}
        title={`${event.accountName}: ${event.title}\n${format(eventStart, 'HH:mm')} - ${format(eventEnd, 'HH:mm')}`}
        onClick={(e) => {
          e.stopPropagation()
          setShowModal(true)
        }}
      >
        <div className="truncate">
          {format(eventStart, 'HH:mm')} - {event.title}
        </div>
      </div>
      {showModal && (
        <AppointmentModal
          accounts={accounts}
          onAppointmentAdded={refreshData}
          selectedEvent={event}
          defaultOpen={true}
          onOpenChange={setShowModal}
        />
      )}
    </>
  )
}

export function Calendar({ accounts, events, refreshData, hasAdminAccess, defaultSelectedAccount, selectedAccounts, onToggleAccount }: CalendarProps) {
  const [isRefreshing, setIsRefreshing] = useState(false)
  const today = startOfToday()
  const [selectedDay, setSelectedDay] = React.useState(today)
  const [currentDate, setCurrentDate] = React.useState(today)
  const [view, setView] = React.useState<ViewType>("month")

  function previousPeriod() {
    setCurrentDate((prev) => {
      switch (view) {
        case "day":
          return add(prev, { days: -1 })
        case "week":
          return add(prev, { weeks: -1 })
        case "month":
          return add(prev, { months: -1 })
        default:
          return prev
      }
    })
  }

  function nextPeriod() {
    setCurrentDate((prev) => {
      switch (view) {
        case "day":
          return add(prev, { days: 1 })
        case "week":
          return add(prev, { weeks: 1 })
        case "month":
          return add(prev, { months: 1 })
        default:
          return prev
      }
    })
  }

  const days = React.useMemo(() => {
    switch (view) {
      case "day":
        return [currentDate]
      case "week":
        return eachDayOfInterval({
          start: startOfWeek(currentDate),
          end: endOfWeek(currentDate),
        })
      case "month":
        return eachDayOfInterval({
          start: startOfWeek(startOfMonth(currentDate)),
          end: endOfWeek(endOfMonth(currentDate)),
        })
      default:
        return []
    }
  }, [currentDate, view])

  function toggleAccount(accountId: string) {
    setSelectedAccounts((current) =>
      current.includes(accountId)
        ? current.filter((id) => id !== accountId)
        : [...current, accountId]
    )
  }

  const filteredEvents = events.filter((event) =>
    selectedAccounts.includes(event.accountId)
  )

  const timeSlots = Array.from({ length: 24 }, (_, i) => i)

  const handleRefresh = async () => {
    setIsRefreshing(true)
    try {
      await refreshData()
    } finally {
      setIsRefreshing(false)
    }
  }

  return (
    <div className="p-4 h-[800px] flex flex-col">
      <div className="space-y-4">
        <div className="flex justify-between items-center bg-white p-4 rounded-lg shadow-sm">
          <div className="flex items-center space-x-4">
            <AccountSelector
              accounts={accounts}
              selectedAccounts={selectedAccounts}
              onToggleAccount={onToggleAccount}
              onAddAccount={(account) => onToggleAccount(account.AccountID)}
            />
            <Button
              variant="outline"
              size="icon"
              onClick={handleRefresh}
              className="hover:bg-gray-50"
              disabled={isRefreshing}
            >
              <RefreshCcw className={cn(
                "h-4 w-4",
                isRefreshing && "animate-spin"
              )} />
            </Button>
          </div>
          <div className="flex gap-2">
            <AppointmentModal accounts={accounts} onAppointmentAdded={handleRefresh} />
          </div>
        </div>

        <div className="flex items-center justify-between bg-white p-4 rounded-lg shadow-sm">
          <div className="flex items-center gap-4">
            <Button
              variant="outline"
              size="icon"
              onClick={previousPeriod}
              className="hover:bg-gray-50"
            >
              <ChevronLeft className="w-4 h-4" />
            </Button>
            <h2 className="text-lg font-semibold text-gray-800">
              {format(currentDate, view === "day" ? "MMMM d, yyyy" : "MMMM yyyy")}
            </h2>
            <Button
              variant="outline"
              size="icon"
              onClick={nextPeriod}
              className="hover:bg-gray-50"
            >
              <ChevronRight className="w-4 h-4" />
            </Button>
          </div>
          <div className="flex gap-2 bg-gray-100 p-1 rounded-md">
            <Button
              variant={view === "day" ? "default" : "ghost"}
              onClick={() => setView("day")}
              className="h-8"
            >
              Day
            </Button>
            <Button
              variant={view === "week" ? "default" : "ghost"}
              onClick={() => setView("week")}
              className="h-8"
            >
              Week
            </Button>
            <Button
              variant={view === "month" ? "default" : "ghost"}
              onClick={() => setView("month")}
              className="h-8"
            >
              Month
            </Button>
          </div>
        </div>
        {view === "month" ? (
          <div className="flex-1 flex flex-col overflow-hidden bg-white rounded-lg shadow-sm">
            <div className="grid grid-cols-7 gap-px text-sm font-medium text-gray-600 bg-gray-50 border-b">
              <div className="p-2 text-center">Sun</div>
              <div className="p-2 text-center">Mon</div>
              <div className="p-2 text-center">Tue</div>
              <div className="p-2 text-center">Wed</div>
              <div className="p-2 text-center">Thu</div>
              <div className="p-2 text-center">Fri</div>
              <div className="p-2 text-center">Sat</div>
            </div>
            <div className="grid grid-cols-7 gap-px flex-1 overflow-y-auto">
              {days.map((day, dayIdx) => (
                <div
                  key={day.toString()}
                  className={cn(
                    "relative min-h-[120px] py-2 px-3 hover:bg-muted/50 cursor-pointer border-b border-r",
                    dayIdx === 0 && colStartClasses[getDay(day)],
                    !isSameMonth(day, currentDate) && "text-muted-foreground",
                    (isEqual(day, selectedDay) || isToday(day)) && "bg-muted/50"
                  )}
                  onClick={() => setSelectedDay(day)}
                >
                  <time
                    dateTime={format(day, "yyyy-MM-dd")}
                    className={cn(
                      "flex h-6 w-6 items-center justify-center rounded-full",
                      isToday(day) && "bg-primary text-primary-foreground",
                      isEqual(day, selectedDay) &&
                        !isToday(day) &&
                        "bg-muted-foreground text-muted-foreground-foreground"
                    )}
                  >
                    {format(day, "d")}
                  </time>
                  {filteredEvents
                    .filter((event) => isSameDay(event.start, day))
                    .filter((event, index, self) => 
                      index === self.findIndex((e) => e.id === event.id)
                    )
                    .map((event) => (
                      <EventDisplay
                        key={event.id}
                        event={event}
                        className={cn(
                          "mt-1 px-1 py-0.5 text-xs rounded truncate",
                          event.color,
                          "text-white"
                        )}
                        accounts={accounts}
                        refreshData={refreshData}
                      />
                    ))}
                </div>
              ))}
            </div>
          </div>
        ) : (
          <div className="flex-1 overflow-hidden">
            <div className="grid grid-cols-[auto,1fr] gap-4 h-full">
              <div className="w-16">
                {timeSlots.map((hour) => (
                  <div key={hour} className="text-right pr-2 h-12">
                    {format(new Date(2024, 0, 1, hour), 'HH:mm')}
                  </div>
                ))}
              </div>
              <div className="relative">
                <div className="grid grid-cols-7 gap-2 mb-2">
                  {days.map((day) => (
                    <div key={day.toString()} className="text-center font-semibold">
                      {format(day, "EEE")}
                      <br />
                      {format(day, "d")}
                    </div>
                  ))}
                </div>
                <div className="grid grid-cols-7 gap-2">
                  {days.map((day) => (
                    <div key={day.toString()} className="relative" style={{ height: `${24 * 48}px` }}>
                      {timeSlots.map((hour) => (
                        <div
                          key={hour}
                          className="absolute w-full border-t border-gray-200"
                          style={{ top: `${hour * 48}px`, height: '48px' }}
                        />
                      ))}
                      {filteredEvents
                        .filter(event => isSameDay(new Date(event.start), day))
                        .map(event => (
                          <EventDisplay
                            key={event.id}
                            event={event}
                            accounts={accounts}
                            refreshData={refreshData}
                          />
                        ))}
                    </div>
                  ))}
                </div>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

const colStartClasses = [
  "",
  "col-start-2",
  "col-start-3",
  "col-start-4",
  "col-start-5",
  "col-start-6",
  "col-start-7",
]
</file>

<file path="app/api/calendar/route.ts">
'use server'

import { NextResponse } from "next/server"
import prisma from '@/app/lib/prisma'
import { Account, CalendarEvent, CalendarEntry } from '@/app/types/calendar'
import { Logger } from '@/app/lib/logger'
import { auth } from '@/app/lib/auth'

const logger = Logger.getInstance()
const FILE_NAME = 'api/calendar/route.ts'

await logger.init()

const COLORS = [

    'bg-blue-500',
    'bg-green-500',
    'bg-purple-500',
    'bg-orange-500',
    'bg-pink-500',
    'bg-teal-500',
    'bg-red-500',
    'bg-yellow-500',
    'bg-indigo-500',
    'bg-cyan-500',
    'bg-emerald-500',
    'bg-violet-500',
    'bg-fuchsia-500',
    'bg-rose-500',
    'bg-lime-500',
    'bg-amber-500',
    'bg-sky-500',
    
    'bg-blue-400',
    'bg-green-400',
    'bg-purple-400',
    'bg-orange-400',
    'bg-pink-400',
    'bg-teal-400',
    'bg-red-400',
    'bg-yellow-400',
    'bg-indigo-400',
    'bg-cyan-400',
    'bg-emerald-400',
    'bg-violet-400',
    'bg-fuchsia-400',
    'bg-rose-400',
    'bg-lime-400',
    'bg-amber-400',
    'bg-sky-400',
    
    'bg-blue-600',
    'bg-green-600',
    'bg-purple-600',
    'bg-orange-600',
    'bg-pink-600',
    'bg-teal-600',
    'bg-red-600',
    'bg-yellow-600',
    'bg-indigo-600',
    'bg-cyan-600',
    'bg-emerald-600',
    'bg-violet-600',
    'bg-fuchsia-600',
    'bg-rose-600',
    'bg-lime-600',
    'bg-amber-600',
    'bg-sky-600'
    
];

export async function GET() {
  try {
    await logger.info(FILE_NAME, 'Calendar API request received')

    const session = await auth()
    if (!session?.user?.orgId) {
      return NextResponse.json(
        { error: 'Unauthorized', type: 'AUTH_ERROR' },
        { status: 401 }
      )
    }

    const isAdmin = session.user.roles.some(r => 
      r.role.name.toLowerCase() === 'admin'
    )
    const isOrganizer = session.user.roles.some(r => 
      r.role.name.toLowerCase() === 'organizer'
    )

    const headers = {
      'Content-Type': 'application/json',
    }

    await prisma.$connect()
    await logger.debug(FILE_NAME, 'Database connection successful')

    // Build the where clause based on user role
    const whereClause = {
      AND: [
        { active: true },
        { orgid: session.user.orgId }
      ]
    }

    // If not admin/organizer, only show the user's own calendar
    if (!isAdmin && !isOrganizer) {
      whereClause.AND.push({ uid: session.user.id })
    }

    const users = await prisma.users.findMany({ where: whereClause })

    if (users.length === 0) {
      await logger.info(FILE_NAME, 'No active users found')
      return NextResponse.json(
        { error: 'No active users found', type: 'NO_USERS' },
        { status: 404, headers }
      )
    }

    await logger.debug(FILE_NAME, `Found ${users.length} active users`)

    const userCalendarEntries = await prisma.user_calendar_entries.findMany({
      where: {
        active: true,
        orgid: 'd290f1ee-6c54-4b01-90e6-d701748f0851',
        user_uid: {
          in: users.map(user => user.uid)
        }
      },
      select: {
        uid: true,
        user_uid: true,
        startdate: true,
        enddate: true,
        description: true,
        title: true
      }
    })

    if (userCalendarEntries.length === 0) {
      await logger.info(FILE_NAME, 'No calendar entries found for active users')
      return NextResponse.json(
        { error: 'No calendar entries found', type: 'NO_ENTRIES' },
        { status: 404, headers }
      )
    }

    await logger.debug(FILE_NAME, `Found ${userCalendarEntries.length} calendar entries`)

    const userCalendarMap = userCalendarEntries.reduce((acc, entry) => {
      const userUid = entry.user_uid
      if (userUid) {
        if (!acc[userUid]) {
          acc[userUid] = [];
        }
        acc[userUid].push(entry);
      }
      return acc;
    }, {} as Record<string, typeof userCalendarEntries>);

    const accounts: Account[] = users.map((user, index) => ({
      AccountID: user.uid,
      Name: user.username ?? `${user.first_name} ${user.surname}`,
      'Calendar-Entries': userCalendarMap[user.uid]?.map((entry) => ({
        uid: entry.uid,
        startdate: entry.startdate?.toISOString() ?? '',
        enddate: entry.enddate?.toISOString() ?? '',
        title: entry.title ?? '',
        description: entry.description ?? '',
        length: '0',
      } as CalendarEntry)) ?? [],
      color: COLORS[index % COLORS.length]
    }))

    const events: CalendarEvent[] = accounts.flatMap((account, accountIndex) =>
      account['Calendar-Entries'].map((entry) => ({
        id: entry.uid,
        title: entry.title,
        description: entry.description,
        start: new Date(entry.startdate),
        end: new Date(entry.enddate),
        accountId: account.AccountID,
        accountName: account.Name,
        color: COLORS[accountIndex % COLORS.length],
      }))
    )

    await logger.info(FILE_NAME, 'Calendar data successfully retrieved')

    return NextResponse.json(
      { accounts, events },
      { headers }
    )

  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : 'Unknown error'
    await logger.error(FILE_NAME, `Failed to fetch calendar data: ${errorMessage}`)
    
    return NextResponse.json(
      { error: 'Failed to fetch calendar data', type: 'SYSTEM_ERROR' },
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    )
  } finally {
    await prisma.$disconnect()
  }
}
</file>

<file path="package.json">
{
  "name": "digifile-app",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "prisma generate && next build --no-lint",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth/prisma-adapter": "^2.7.4",
    "@headlessui/react": "^2.2.0",
    "@hookform/resolvers": "^3.9.1",
    "@prisma/client": "^6.0.1",
    "@radix-ui/react-checkbox": "^1.1.4",
    "@radix-ui/react-dialog": "^1.1.2",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-radio-group": "^1.2.3",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-tooltip": "^1.1.4",
    "@supabase/supabase-js": "^2.47.12",
    "@tiptap/pm": "^2.11.7",
    "@tiptap/react": "^2.11.7",
    "@tiptap/starter-kit": "^2.11.7",
    "chalk": "^5.4.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^4.1.0",
    "framer-motion": "^11.15.0",
    "lucide-react": "^0.463.0",
    "next": "15.2.4",
    "next-auth": "^5.0.0-beta.25",
    "react": "19.1.0",
    "react-datepicker": "^7.5.0",
    "react-dom": "19.1.0",
    "react-hook-form": "^7.54.1",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.0.3",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@tailwindcss/typography": "^0.5.16",
    "@types/node": "^20",
    "@types/react": "19.0.12",
    "@types/react-dom": "19.0.4",
    "eslint": "^8",
    "eslint-config-next": "15.2.4",
    "postcss": "^8",
    "prisma": "^6.0.1",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  },
  "overrides": {
    "@types/react": "19.0.12",
    "@types/react-dom": "19.0.4"
  }
}
</file>

</files>
